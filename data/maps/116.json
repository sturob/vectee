{"functions":{"initial":"_.extend(v, { \n  tileSize: 256, \n  cluster_range: 250,\n  redraw_delay: 300,\n  count: 0,  venues: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ],\n  exclude_categories: a2o([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket', 'Church',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store',\n    'Moving Target', 'Road', 'Residential Building (Apartment/Condo)', 'Strip Club'\n  ])\n});\n\nv.QuadTree = {\n  all: {}\n};\n\nwindow.Scan = {\n  queue: []\n};\n\n\nwindow.cluster = {\n  venues: [],\n  active: function() { return (cluster.venues.length > 0) },\n  contains: function(venue) { return _.contains(cluster.venues, venue) },\n  clear: function(){\n    cluster.venues = [];\n    v.dotTiles.setOpacity( 0.99 );\n    v.clusterTiles.redraw();\n//    v.dotTiles.redraw();\n  }\n}\n\nL.llz_to_tile = function( lat, lng, zoom ) {\n  function lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\n  function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\n\n  return [ zoom, long2tile(lng, zoom), lat2tile(lat, zoom) ];\n}\n\nL.tile_to_llbounds = function(zz, xx, yy) {\n  function tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\n  function tile2lat(y,z) {\n    var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n    return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n  }\n  \n  return new L.LatLngBounds(\n    new L.LatLng( tile2lat(yy, zz),   tile2long(xx, zz) ),\n    new L.LatLng( tile2lat(yy+1, zz), tile2long(xx+1, zz) )\n  );\n};\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n};\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/v.tileSize ) * v.tileSize,\n        y1: Math.floor( bounds.min.y/v.tileSize ) * v.tileSize,\n        x2: Math.ceil( bounds.max.x/v.tileSize ) * v.tileSize,\n        y2: Math.ceil( bounds.max.y/v.tileSize ) * v.tileSize\n      };\n  return locked;\n};\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var cols = Math.ceil((locked.x2 - locked.x1) / v.tileSize),\n      rows = Math.ceil((locked.y2 - locked.y1) / v.tileSize),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (v.tileSize * i), \n          y  = locked.y1 + (v.tileSize * j),\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + v.tileSize, y + v.tileSize) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n};\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/65711/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n  \n  v.dotTiles = new L.TileLayer.Canvas();\n  v.dotTiles.drawTile = function(canvas, tilePoint, zoom) { };\n  v.map.addLayer(v.dotTiles);\n}\n\n\nv.clusterTiles = new L.TileLayer.Canvas();\nv.map.addLayer(v.clusterTiles);\n\nv.layergroup = new L.LayerGroup();\nv.map.addLayer( v.layergroup );\n\nv.map.on('click', function(e) {\n  \n  if (! cluster.active()) {\n    cluster.gather( e.latlng );\n  } else {\n    cluster.clear();\n  }\n});\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n","paperjs":"//paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n  var n = 0;\n  _.each(v.scans, function(quad) {\n     \n/*    var poly = L.Polygon([ \n      quad.bounds.getNorthWest(), quad.bounds.getNorthEast(),\n      quad.bounds.getSouthEast(), quad.bounds.getSouthWest()\n    ], {}); */\n    \n    //v.map.addLayer(poly);\n    /*\n    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25); */\n  });\n};\n\n\n\n\n","instant":"\nwindow.highlightBounds = function(tmpbounds) {\n  var corners = [ tmpbounds.getNorthWest(), tmpbounds.getNorthEast(),\n                  tmpbounds.getSouthEast(), tmpbounds.getSouthWest() ];\n\n  v.polyline = new L.Polyline( corners, { fill: true, color: 'black', stroke: false });\n  v.layergroup.clearLayers();\n  v.layergroup.addLayer( v.polyline );\n};\n\nwindow.tilesForLocation = function(ll) {\n  var tiles = [];\n  for (var i=1; i<19; i++) {\n    tiles.push( L.llz_to_tile(ll.lat, ll.lng, i) );\n  }\n  return tiles;\n};\n\nwindow.tilePos = function(ll, tilePoint) {\n  var point = v.map.project( ll );\n  return {  x: point.x - tilePoint.x * v.tileSize,  y: point.y - tilePoint.y * v.tileSize  };\n};\n\nwindow.zoomAdjust = function() {\n   return Math.pow(2, v.map.getZoom()) / 26214.4;\n};\n\nv.calcScore = function(venue) {\n  return 10 * Math.pow(venue.stats.usersCount/100 * venue.stats.checkinsCount/20, 0.1);\n};\n\n// ============ scanning =============\n\n_.extend(Scan, {\n  paused:   false,\n  fake:     true,  // dont call foursquare, just show the scanning\n  userless: true,  // 5000/hour instead of 500, but no user info\n  max_level: 17,   // smallest tile level to scan\n  recurse_n: 3     // how many levels to recurse when scanning\n}); \n\nScan.refetch = function(){\n  //window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  Scan.queue = [];\n  Scan.start();\n};\n\nScan.start = function() {\n  var\tcenter = v.map.getBounds().getCenter();\n  var initial_level = v.map.getZoom();\n \n  Scan.queue = _( v.map.getVisibleTiles() ).chain().map( function(tile) {\n    var quad = new v.Quad( tile, initial_level ); // hacky\n    return v.QuadTree.get( quad.key() );\n  }).sortBy( function(quad) { // sort by closest to the center\n    return quad.bounds.getCenter().distanceTo( center );\n  }).value();\n\n  nextScan();\n\n  function nextScan() {\n    v.layergroup.clearLayers();\n    v.dotTileQueue.throttledRedraw();\n    \n    if (Scan.paused) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = Scan.queue.shift()) {\n      if (up_next.level < (initial_level + Scan.recurse_n) && \n          up_next.level <= Scan.max_level) \n      {\n        highlightBounds( up_next.bounds );        \n        up_next.scan( nextScan );\n        break;\n      }\n    }\n  }\n};\n\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z   = v.Quad.offZero,\n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?' + 'v=20120514&' +\n            (Scan.userless ? \n              'client_id=2YR33TS505QZQJNYIXEBOYLELJEPTLNAO4LVBRA3QJS3Z421&' +\n              'client_secret=OIUPQA2AB0OSVZXQDVCXGITU3F3BVP0XFP5QT2ODWZ4WXZQW&' : \n              'oauth_token=ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&') +\n            'intent=browse&' + 'limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n    \n  if (Scan.fake) {\n    var kids = quad.divide();\n    Scan.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    _.delay(function(){ if (callback) callback(); }, 20);\n    return;\n  }\n  \n  var got = function (res) {\n    _(res.response.venues).each( insertVenue );\n    if (callback) callback(res); // tail recursion\n  };\n  \n  if ( v.QuadTree.get( key ).done() ) {\n    console.warn('already fetched: ' + key);\n    if (callback) callback(); // tail recursion\n  } else {\n    console.warn('fetching ' + key);\n    window.currentQuery = $.getJSON(url + url2, got).error(function(res){\n      alert(JSON.parse(res.responseText).meta.errorDetail);\n    });\n  }\n};\n\n\nwindow.insertVenue = function(venue) {  \n  if (! v.venues[venue.id]) { // add venue if it's new\n    if (venue.categories.length) {\n      if (venue.categories[0].name in v.exclude_categories) { venue.hide = true; }\n    }\n    venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n    venue.color = get_random_color();\n    v.venues[venue.id] = venue;\n  }\n  \n  var tiles = tilesForLocation( venue.location );\n  _.each(tiles, function(tile){\n    var quad = v.QuadTree.get( tile.join('/') );\n    if (! quad.venues[ venue.id ]) {\n      quad.venues[ venue.id ] = venue;\n    }\n  });\n};\n\n\n// ======= QuadTree ========\n\nv.QuadTree.get = function(id) { // make if none\n  var quad = v.QuadTree.all[id],\n      tile = id.split('/');\n  if (! quad) {\n    quad = new v.Quad( L.tile_to_llbounds(tile[0]-0, tile[1]-0, tile[2]-0), tile[0]-0 );\n    v.QuadTree.add( quad );\n  }\n  return quad;\n};\n\nv.QuadTree.add = function(quad) { // don't overwrite\n  var existing = v.QuadTree.all[ quad.key() ];\n  if (! existing) {\n    v.QuadTree.all[ quad.key() ] = quad;\n  }\n};\n\n\n// ======= dotTileQueue : divides main tile rendering up into small chunks =======\n\nv.dotTiles.drawTile = function() { // add to queue\n  v.dotTileQueue.renderQueue.push({\n    canvas: arguments[0], tilePoint: arguments[1], zoom: arguments[2]\n  });\n  //log('drawTile() tile queued: ');// + arguments[1]);\n};\n\nv.dotTileQueue = {\n  lazies: [],\n  cancelRender: function(){\n    //  log('cancelRender() ' + v.lazies.length + ' lazies & ' + v.renderQueue.tasks.length + ' renders');\n    _(v.dotTileQueue.lazies).each(function(lazy) {\n      if (lazy) lazy(); // cancel\n    });\n    v.dotTileQueue.lazies = [];\n    v.dotTileQueue.tasks = [];\n    v.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n  },\n  drawTile: function(args, callback) {\n    var canvas = args.canvas,  tilePoint = args.tilePoint,  zoom = args.zoom,\n        key    = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n        ctx    = canvas.getContext('2d'),\n        quad   = v.QuadTree.get( key ),\n        venues = //(v.map.getZoom() < 14) ? quad.venues : \n        quad.getNearbyVenues();\n        \n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    var options = { complete: callback,  partSize: 40,  breathTime: 5 };\n    var lazy = $.lazyEach(venues, function(n, venue){ venue = this; \n      var score = v.calcScore( venue ),\n          zoom  = zoomAdjust(),\n          size  = Math.max( .5, Math.min(score*zoom*0.5, 20) );\n          \n      //if (! venue.hide && ! venue.location.isFuzzed) { // var x = 11, y = 30 + 14*i++;\n        var pos   = tilePos(venue.location, tilePoint);\n        ctx.prop({ fillStyle: '#000' }).circle( pos.x, pos.y, size ).fill();\n      //}\n    }, options);\n    \n    v.dotTileQueue.lazies.push( lazy ); // we might have to cancel them shortly\n  }\n};\n\nv.dotTileQueue.throttledRedraw = _.debounce(function(){\n  v.dotTileQueue.cancelRender();\n  v.dotTiles.redraw();\n}, v.redraw_delay);\n\nv.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n\n\n\n\n// =========== CLUSTER =============\n\nv.clusterTiles.drawTile = function(canvas, tilePoint, zoom) { \n  var key = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n      ctx = canvas.getContext('2d');\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 50, fillStyle: '#fff', strokeStyle: '#333'\n    }).moveTo( center.x, center.y ).fill();\n    \n    // TODO: performance\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue) {\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y ).moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n    \n    _(cluster.venues).each(function(venue) {\n      var pos = tilePos(venue.location, tilePoint);\n      ctx.prop({ fillStyle: venue.color }).circle( pos.x, pos.y, 8 ).fill();\n    });\n  }\n};\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll; }) );\n};\n\nwindow.cluster.center = function() {\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return { lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng) };\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n};\n\nwindow.cluster.getCloseVenues = function(ll) {\n  var zoom = 15, // OPTIMISE\n      tile = L.llz_to_tile( ll.lat, ll.lng, zoom );\n  return v.QuadTree.get( tile.join('/') ).getNearbyVenues();\n};\n\nwindow.cluster.getClosestVenues = function(ll) {\n  return _( cluster.getCloseVenues(ll) ).sortBy(function(venue){\n    return venue.ll.distanceTo( ll );\n  });\n};\n\nwindow.cluster.gather = function (ll) {\n  var localVenues = cluster.getClosestVenues(ll),\n      closest     = localVenues[0];\n\n  if (!closest || ll.distanceTo(closest.ll) > zoomAdjust()*500) { // TODO include zoom level\n    cluster.clear();\n    return;\n  }\n  \n  v.dotTiles.setOpacity( 0.6 );\n  \n//  v.dotTileQueue.cancelRender();\n  cluster.venues = _(localVenues)\n    .chain()\n    .filter(function(venue){ return venue.ll.distanceTo( ll ) < (v.cluster_range); })\n    .slice(0, 12)\n    .sortBy(function(venue) { return -venue.ll.lat; })\n    .value();\n\n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  var bounds   = cluster.bounds(),\n      distance = bounds.getNorthWest().distanceTo( bounds.getSouthEast() );\n\n  var text = //'<p style=\"text-align: center\"><em>' + Math.floor(distance / 90) + ' mins walking</em></p>' +  \n    _.map(cluster.venues, function(venue) {\n      var str = \n      '<b style=\"-webkit-border-radius: 8px; padding: 0 6px;' + \n         'background-color: <%= color %>\">&nbsp;</b> ' +\n        '<a target=\"_new\" href=\"http://foursquare.com/v/<%= id %>\"><%= name %></a>' +\n        ' <em>'+ cat(venue) + '</em><br>';\n    return _.template(str)(venue);\n  }).join(' ');\n\n  popup( \n    new L.LatLng( cluster.venues[0].ll.lat, cluster.venues[0].ll.lng ), \n    text \n  );\n  \n  v.clusterTiles.redraw();\n};\n\n\nv.dotTileQueue.throttledRedraw();\n\n\n\n\n\n// =========== Quad class =============\n\nv.Quad = function(bounds, level) {\n  this.level = level;\n  this.bounds   = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() );\n  this.venues   = {};\n\n  var tile = this.tile();\n  this.x = tile[1];\n  this.y = tile[2];\n  this.z = tile[0]; \n\n//this.hit_count      0-50\n//this.ajax_done  boolean\n  \n  return this;\n};\n\nv.Quad.offZero = function(num) { // hack for foursquare API\n  return num === 0 ? '0.00000000001' : num + '';\n};\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    if (results) {\n      that.ajax_complete = true;\n      //if (results.response.venues.length == 50) { // squeeze out some kids\n        //log('kids');\n        var kids = that.divide();\n        //getChildrenTiles\n        v.queue.push( kids[0], kids[1], kids[2], kids[3] );\n      //}\n    }\n    \n    if (callback) callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var that = this,\n      directions = [  [-1, -1], [-1, +0], [-1, +1],\n                      [+0, -1], /*[0,0]*/ [+0, +1],\n                      [+1, -1], [+1, +0], [+1, +1]  ];\n  \n  return _.map( directions, function(dir) {\n    return [ that.z,  that.x + dir[0],  that.y + dir[1] ];\n  });\n};\n\nv.Quad.prototype.getNearbyVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles  = this.getNeighbouringTiles();\n  \n  _.each(tiles, function(t) {\n    var quad = v.QuadTree.get( t.join('/') );\n    if (quad) {\n      _.extend( venues, quad.venues );\n    }\n  });\n\n  venues = _.filter(venues, function(venue){ \n    var score = v.calcScore( venue );\n    return !venue.hide && (score > highpass);\n  });\n  \n  return venues;\n};\n\nv.Quad.prototype.getParentTile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, level - 1);\n};\n\nv.Quad.prototype.getChildrenTiles = function(){\n  var zz = this.z + 1,  x = this.x,  y = this.y;\n      \n  return [\n    [ zz, 2*x, 2*y ],    [ zz, 2*x + 1, 2*y ],\n    [ zz, 2*x, 2*y + 1], [ zz, 2*x + 1, 2*y + 1 ]\n  ];\n};\n\nv.Quad.prototype.tile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.level );\n};\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n};\n\nv.Quad.prototype.done = function() {\n  return (this.level < 19) && (this.ajax_complete || _(this.getChildrenTiles()).all( function(tile_arr) {\n    return v.QuadTree.get( tile_arr.join('/') ).done();\n  }));\n};\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter(); },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( x, ne), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( s, e ), this.level + 1 )\n  ];\n};\n\n\n\n////////\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: false, offset: new L.Point(0, -24)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n};\n\n","unpause":"\nScan.start()\n\n\n","canvas":"  "},"parameters":{"labels":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 10460, -100)","weight":null,"manual":0.49,"id":"labels"},"power":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 0, 1)","weight":null,"manual":0.4,"id":"power"},"highpass":{"initial":0.5,"raw":0.5,"formula":"coax(slider, -1, 40)","weight":null,"manual":0.28,"id":"highpass"}},"iteration":116}