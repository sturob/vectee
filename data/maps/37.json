{
  "functions": {
    "initial": "paper.project.layers[0].removeChildren();\n_.extend(v, { \n  count: 0,  venues: {},  searches: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ], \n  exclude_categories: {\n    'Neighborhood': true, 'Bank':true, 'Government Building':true,\n    'Gym':true,  'College Academic Building':true,\n    'Office':true,  'College Residence Hall':true,\n    'Bus Station':true, 'Train Station':true, 'Bus Line': true,\n    'Subway':true,  'Light Rail':true, 'Train': true, 'Platform': true,\n    'Highway or Road':true, 'Home (private)':true, 'Hospital': true\n  }\n})\n\nv.ll2p = function(lat, lng) {\n  return v.map.layerPointToContainerPoint( v.map.latLngToLayerPoint( new L.LatLng(lat, lng) ) );\n};\n\nv.LL_to_Point = function(ll) {\n  return v.map.layerPointToContainerPoint( v.map.latLngToLayerPoint( ll ) );\n};\n\nv.calcScore = function(venue) {\n  return venue.stats.usersCount/100 * venue.stats.checkinsCount/20;\n};\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/62930/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  $(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n\n  v.map.off('click').on('click', function(e) {\n    if (e.originalEvent.shiftKey) {\n      fetchVenues(e.latlng);\n    } else {\n      cluster(e.latlng)\n    }\n  });\n}\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n",
    "paperjs": "paper.project.layers[0].removeChildren();\n\nif (v.cluster.length > 0) {\n  var path = new Path();\n  if (v.cluster.length > 2) path.closed = true;\n  path.segments = [];\n  for (var i=0; i < v.cluster.length; i++) {\n    path.add( v.ll2p( v.cluster[i].ll.lat, v.cluster[i].ll.lng ) );\n  }\n  path.smooth();\n  _.extend( path, {\n    strokeColor: '#fff', fillColor: '#fff', strokeWidth: 43, strokeCap: 'round'\n  });\n}\n\n_.each(v.scans, function(quad) {\n  var rec = new Path.Rectangle(\n    v.LL_to_Point( quad.bounds.getNorthWest() ),\n    v.LL_to_Point( quad.bounds.getSouthEast() )\n  );\n  window.rec = rec;\n  rec.opacity = 0.9; rec.fillColor = '#f00';\n});\n\n\n_.each(v.venues, function(venue) {\n  var size = v.calcScore(venue);\n  \n  if (size < highpass || venue.hide) return;\n  \n  var pos = v.map.layerPointToContainerPoint( \n    v.map.latLngToLayerPoint( new L.LatLng( venue.location.lat, venue.location.lng ) )\n  );\n  var p = new Point([pos.x, pos.y]);\n  var dot = new Path.Circle(p,  Math.min( Math.pow(size, power), 20) );\n  \n  if (v.cluster.length == 1 && (v.cluster[0].id == venue.id)) {\n    dot = new Path.Circle(p, 22);\n    dot.fillColor = '#000';\n  } else if (v.cluster.length > 1) {\n    var in_cluster = _(v.cluster).any(function(item){ \n      return item.id == venue.id\n    });\n    if (in_cluster) {\n      dot = new Path.Circle(p, 10);\n      dot.fillColor = venue.color || '#000';\n    }\n  } else {\n    dot.fillColor = '#000';\n  }\n});\n",
    "instant": "var search_radius = 250; // metres\nvar url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n          'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n          '&intent=browse' + '&limit=50';\n\nwindow.fetchVenues = function(ll1, ll2, callback) {\n  var key = '' + ll1.lat + ll1.lng,\n      url2 = '';\n\n  if (ll2) {\n    key += ll2.lat + ll2.lng;\n    if (v.scans[key]) return; // stop dupe searches\n    url2 = '&sw=' + ll1.lat +',' + ll1.lng + '&ne=' + ll2.lat +',' + ll2.lng; ;\n  } else {\n    if (v.searches[key]) return; // stop dupe searches\n    url2 = '&radius=' + search_radius + '&ll=' + ll1.lat +',' + ll1.lng;\n  }\n  console.log('searching:' + key);\n  \n  window.currentQuery = $.getJSON(url + url2, function(res){\n    console.log('found ' + res.response.venues.length);\n    window.results = res; // test\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name in v.exclude_categories) {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    delete v.searches[key];\n    delete v.scans[key];\n    console.log('total venues = ' + _( v.venues ).keys().length);\n    \n    callback && callback(res);\n  });\n};\n\n\n\n\nv.Quad = function(bounds, parent){\n  this.bounds = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() )\n  this.children = [];\n  this.parent = parent;\n  // this.hit_count     n 0-50\n  // this.ajax_complete boolean\n  if (parent) parent.children.push( this );\n  return this;\n}\n\nv.Quad.prototype.finished = function() {\n  if (! this.ajax_complete) return false;\n  if (this.result_count < 50) return true;    // got fewer than complete results\n  if (this.children.length < 4) return false; // \n  if (this.children.length == 4) {\n    return this.children[0].finished() && this.children[1].finished() &&\n           this.children[2].finished() && this.children[3].finished();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds;\n  \n  function midLL(ll1, ll2) {\n    return new L.LatLng( (ll1.lat + ll2.lat)/2,  (ll1.lng + ll2.lng)/2 );\n  }\n  \n  var sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n = midLL(nw, ne),      s = midLL(sw, se),\n      w = midLL(nw, sw),      e = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this ),\n    new v.Quad( new L.LatLngBounds( x, ne), this ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this ),\n    new v.Quad( new L.LatLngBounds( s, e ), this )\n  ];\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  console.log('scanning size:' + this.diagonal);\n  \n  var onScanned = function(results) {\n    venues = results.response.venues;\n    console.log('added venues #' + venues.length);\n    \n    that.ajax_complete = true;\n    that.result_count = venues.length;\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] )\n      that.children = kids;\n    }\n    callback && callback();\n  };\n  \n  fetchVenues( that.bounds.getSouthWest(), that.bounds.getNorthEast(), onScanned );\n};\n\nwindow.startScan = function(map) {\n  v.queue = [];\n  var root_bounds = map.getBounds();\n  v.root = new v.Quad( root_bounds ); // currently the initial screen\n  \n  v.root.scan( nextScan );\n\n  function nextScan() {\n    if (v.pauseScan) {\n      setTimeout(nextScan, 10000);\n      return;\n    }\n\n    var up_next = v.queue.shift();\n    \n    if (up_next.diagonal < 350) return; // too close\n    v.scans.push( up_next );\n    up_next.scan( nextScan );\n  }\n}\n\nv.findWithin = function (here, metres) {\n  return _.filter(v.venues, function(venue){\n    var score = v.calcScore( venue );\n    venue.distance = venue.ll.distanceTo( here.ll );\n    return !venue.hide && (score>highpass) && metres > venue.distance;\n  });\n};\n\nwindow.cluster = function (ll) {\n  var closest; // id + distance\n\n  function findClosest(here, all) {\n    var best = null;\n    _.each(all, function(venue) {\n      var score = v.calcScore( venue );\n      if (! best) {\n        best = { id: venue.id, distance: venue.ll.distanceTo( ll ) };\n        return;\n      }\n      if (venue.hide) return;\n      \n      var distance = venue.ll.distanceTo( here );\n      if (distance < best.distance && score > highpass) {\n        best = { id: venue.id, distance: distance };\n      }\n    });\n    return best;\n  }\n  \n  function findCluster(venue, possibles) {\n    v.cluster = v.findWithin(venue, 250); // TODO use zoom level\n    return;\n  }\n  \n  closest = findClosest( ll, v.venues ); // find closest venue to tap\n  \n  if (closest.distance > 100) { // TODO include zoom level\n    v.cluster = [];\n    return;\n  }\n\n  v.cluster = [ v.venues[closest.id] ];\n  var venues = _.clone(v.venues);\n\n  findCluster(v.cluster[0], venues);\n  \n  // order by proximity and limit to 12\n  v.cluster = _(v.cluster).sort(function(a, b){ return a.distance > b.distance });\n  v.cluster = v.cluster.slice(0, 12);\n  \n  function cat(venue) {\n  \n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  \n  var highest = v.cluster[0];\n  _.each(v.cluster, function(venue) {\n    if (venue.ll.lat > highest.ll.lat) highest = venue;\n  });\n  \n  var text =  _.map(v.cluster, function(venue) {\n      return '<b style=\"-webkit-border-radius: 8px; padding: 0 6px; background-color:'\n            + venue.color + '\">&nbsp;</b> '\n            + '<a target=\"_new\" href=\"http://foursquare.com/v/' + venue.id + '\">' \n            + venue.name +  '</a> <em>'+ cat(venue) + '</em><br>'\n    }).join(' ');\n    \n  popup( highest.ll, text );\n}\n\nwindow.refetch = function(){\n  window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  window.queue = [];\n  \n  window.startScan( v.map );\n}\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup();\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n",
    "unpause": "\n// save full screen bounds for post-scrolling action later\nvar b = v.map.getBounds();\nfetchVenues( b.getSouthWest(), b.getNorthEast() );\n\nvar tileSize = 256;\n \nvar bounds = v.map.getPixelBounds();\n\nvar nw = v.map.layerPointToLatLng(\n      new L.Point( Math.floor(bounds.min.x/tileSize), Math.floor(bounds.min.y/tileSize) )\n    ),\n    se = v.map.layerPointToLatLng(\n      new L.Point( Math.floor(bounds.max.x/tileSize), Math.floor(bounds.max.y/tileSize) )\n    );\n\nv.scans[0] = { bounds: new L.LatLngBounds(nw, se) };\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.42,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.11,
      "id": "highpass"
    }
  },
  "iteration": 37
}