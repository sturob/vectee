{"functions":{"initial":"_.extend(v, { \n  tileSize: 256, \n  venues: {},  scans: [],\n  geopos:  [ 51.544303, -0.051344 ],\n  exclude_categories: _.spawn([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket', 'Church',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store',\n    'Moving Target', 'Road', 'Residential Building (Apartment/Condo)', 'Strip Club'\n  ])\n});\n\nv.Quad = function(bounds, z) {\n  this.bounds   = bounds;\n  this.venues   = {};\n  this.z        = z;\n  \n  var tile = this.tile();\n  this.x = tile[1];\n  this.y = tile[2];\n//this.venues_count   0-50\n//this.fetched_at     Date int\n  return this;\n};\n\nv.QuadTree = {\n  all: {}\n};\n\nwindow.Scan = {\n  queue: []\n};\n\n\nwindow.cluster = {\n  venues: [],\n  active: function() { return (cluster.venues.length > 0) },\n  contains: function(venue) { return _.contains(cluster.venues, venue) },\n  clear: function(){\n    cluster.venues = [];\n    v.dotTiles.setOpacity( 0.99 );\n    v.clusterTiles.redraw();\n  }\n}\n\n\nwindow.highlightBounds = function(tmpbounds) {\n  var corners = [ tmpbounds.getNorthWest(), tmpbounds.getNorthEast(),\n                  tmpbounds.getSouthEast(), tmpbounds.getSouthWest() ];\n\n  v.polyline = new L.Polyline( corners, { fill: true, color: 'black', stroke: false });\n  v.layergroup.clearLayers();\n  v.layergroup.addLayer( v.polyline );\n};\n\nwindow.tilePos = function(ll, tilePoint) {\n  var point = v.map.project( ll );\n  return {  x: point.x - tilePoint.x * v.tileSize,  y: point.y - tilePoint.y * v.tileSize  };\n};\n\nL.LatLng.prototype.getAllTiles = function() {\n  var ll = this;\n  return _.range(1, 19).map(function(n) {\n    return L.llz_to_tile(ll.lat, ll.lng, n)\n  });\n};\n\nL.llz_to_tile = function( lat, lng, zoom ) {\n  function lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\n  function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\n\n  return [ zoom, long2tile(lng, zoom), lat2tile(lat, zoom) ];\n}\n\nL.tile_to_llbounds = function(zz, xx, yy) {\n  function tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\n  function tile2lat(y,z) {\n    var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n    return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n  }\n  \n  return new L.LatLngBounds(\n    new L.LatLng( tile2lat(yy, zz),   tile2long(xx, zz) ),\n    new L.LatLng( tile2lat(yy+1, zz), tile2long(xx+1, zz) )\n  );\n};\n\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n};\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/v.tileSize ) * v.tileSize,\n        y1: Math.floor( bounds.min.y/v.tileSize ) * v.tileSize,\n        x2: Math.ceil( bounds.max.x/v.tileSize ) * v.tileSize,\n        y2: Math.ceil( bounds.max.y/v.tileSize ) * v.tileSize\n      };\n  return locked;\n};\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var cols = Math.ceil((locked.x2 - locked.x1) / v.tileSize),\n      rows = Math.ceil((locked.y2 - locked.y1) / v.tileSize),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (v.tileSize * i), \n          y  = locked.y1 + (v.tileSize * j),\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + v.tileSize, y + v.tileSize) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n};\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/65711/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n  \n  v.dotTiles = new L.TileLayer.Canvas();\n  v.dotTiles.drawTile = function(canvas, tilePoint, zoom) { };\n  v.map.addLayer(v.dotTiles);\n}\n\n\nv.clusterTiles = new L.TileLayer.Canvas();\nv.map.addLayer(v.clusterTiles);\n\nv.layergroup = new L.LayerGroup();\nv.map.addLayer( v.layergroup );\n\nv.map.on('click', function(e) {\n  \n  if (! cluster.active()) {\n    cluster.gather( e.latlng );\n  } else {\n    cluster.clear();\n  }\n});\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n","paperjs":"//paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n  var n = 0;\n  _.each(v.scans, function(quad) {\n     \n/*    var poly = L.Polygon([ \n      quad.bounds.getNorthWest(), quad.bounds.getNorthEast(),\n      quad.bounds.getSouthEast(), quad.bounds.getSouthWest()\n    ], {}); */\n    \n    //v.map.addLayer(poly);\n    /*\n    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25); */\n  });\n};\n\n\n\n\n","instant":"window.zoomAdjust = function() {\n   return Math.pow(2, v.map.getZoom()) / 26214.4;\n};\n\nv.calcScore = function(venue) {\n  return 11 * Math.pow(venue.stats.usersCount/100 * venue.stats.checkinsCount/20, 0.12);\n};\n\n// var Viz = {  };\n\n_.extend(v, {\n  cluster_range: 250,\n  redraw_delay:  500,\n  dot_size:        6, \n  cluster_thick:  10 \n});\n\n// ============ scanning =============\n\nScan.cancel && Scan.cancel();\n\n_.extend(Scan, {\n  paused:    false,  fake: false,  // dont call foursquare, just viz the scan\n  userless:   true,  // 5000/hour instead of 500, but no user info\n  max_level:    18,  // smallest tile level to scan\n  recurse_n:    10,  // how many levels to recurse when scanning\n  load_crap:  true   // load all venues inc. .hide and low scoring\n});\n\nScan.refetch = function(){\n  //window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  Scan.cancel();\n  Scan.start();\n};\n\nScan.cancel = function() {\n  console.log('Cancelling');\n  v.layergroup.clearLayers();\n  Scan.queue = [];\n};\n\nScan.save = function(){\n  var save = {\n    venues: v.venues,\n    scanned: _.spawn( _( v.QuadTree.all ).keys().filter(function(k){ // scanned keys\n                        return v.QuadTree.get(k).fetched_at;\n                      }),\n                      function() { // what to save\n                        return _.pick(v.QuadTree.get(this), 'fetched_at', 'venue_count' );\n                      })\n  };\n  \n  console.log('saving ' + _(save.venues).size() + ' venues & ' + _(save.scanned).size() + ' quads')\n  $.post(\"http://localhost:6969/basic/london_scan.json\", JSON.stringify(save));\n};\n\n\nScan.load = function(){\n  $.get(\"http://localhost:6969/basic/london_scan.json\", function(res){\n    var save = JSON.parse(res);\n    \n    console.log('loading ' + save.venues.length + ' venues & ' + _(save.scanned).size() + ' quads')\n    \n    if (save) {\n      v.QuadTree.all = {};\n      _.each(save.scanned, function(data, key) {\n        var quad = v.QuadTree.get( key );\n        _.extend( quad, data );\n      });\n      v.venues = save.venues;\n      _.each( v.venues, populateVenue );\n      reloadVenues();\n    }    \n  });\n}\n\n\nScan.start = function() {\n  var\tcenter = v.map.getBounds().getCenter(),\n      initial_level = v.map.getZoom();\n \n  Scan.queue = _( v.map.getVisibleTiles() ).chain().map( function(tile) {\n    var quad = new v.Quad( tile, initial_level ); // hacky\n    return v.QuadTree.get( quad.key() );\n  }).sortBy( function(quad) { // sort by closest to the center\n    return quad.bounds.getCenter().distanceTo( center );\n  }).value();\n\n  nextScan();\n\n  function nextScan() { // called when a scan is complete, inits the next scan\n    v.layergroup.clearLayers();\n    v.dotTileQueue.throttledRedraw();\n    \n    if (Scan.paused) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = Scan.queue.shift()) {\n      if ((up_next.z < (initial_level + Scan.recurse_n)) && // max amount to recurse\n          (up_next.z <= Scan.max_level) &&                  // max level to ever scan\n          true )\n      {\n        highlightBounds( up_next.bounds );\n        up_next.scan( nextScan );\n        break; // leave the while()\n      }\n    }\n  }\n};\n\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z   = v.Quad.offZero,\n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?' + 'v=20120514&' +\n            (Scan.userless ? \n              'client_id=2YR33TS505QZQJNYIXEBOYLELJEPTLNAO4LVBRA3QJS3Z421&' +\n                'client_secret=OIUPQA2AB0OSVZXQDVCXGITU3F3BVP0XFP5QT2ODWZ4WXZQW&' : \n              'oauth_token=ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&') +\n            'intent=browse&' + 'limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n\n  if (Scan.fake) {\n    var kids = quad.divide();\n    Scan.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    _.delay(function(){ if (callback) callback(); }, 20);\n    return;\n  }\n  \n  var real_quad = v.QuadTree.get( key );\n  \n  if (! real_quad.worthScanning()) {\n    console.warn('nah');\n    if (callback) callback(); // tail recursion\n  } else if ( real_quad.done() ) {\n    console.warn('already fetched z:' + real_quad.z);\n    if (callback) callback(); // tail recursion\n  } else {\n    console.warn('fetching ' + key);\n    var got = function (res) {console.warn(res.response.venues.length)\n      _(res.response.venues).each( insertVenue );\n      if (callback) callback(res); // tail recursion\n    };\n    \n    window.currentQuery = $.getJSON(url + url2, got).error(function(res){\n      alert(JSON.parse(res.responseText).meta.errorDetail);\n    });\n  }\n};\n\n// ==============================\n\n// load venues into Quads\nwindow.reloadVenues = function(){\n  _.each(v.QuadTree.all, function(quad) {\n    quad.venues = {};\n  });\n  _(v.venues).each( insertVenue );\n  v.dotTileQueue.throttledRedraw();\n};\n\nwindow.populateVenue = function (venue) {\n  venue.hide  = !!venue.categories.length && (venue.categories[0].name in v.exclude_categories);\n  venue.score = v.calcScore( venue );\n  venue.ll    = new L.LatLng( venue.location.lat, venue.location.lng );\n  venue.color = get_random_color();\n\n  return venue;\n}\n\n// load venue into v.venues and Quad.venues\nwindow.insertVenue = function(venue) {\n  \n  if (! v.venues[venue.id]) { // add venue if it's new\n    populateVenue( venue );\n    v.venues[venue.id] = venue;\n  }\n  \n  if (Scan.load_crap || (venue.score > highpass && !venue.hide)) {\n    var tiles = venue.ll.getAllTiles();\n    _.each(tiles, function(tile){\n      var quad = v.QuadTree.get( tile.join('/') );\n      if (! quad.venues[ venue.id ]) {\n        quad.venues[ venue.id ] = venue;\n      }\n    });\n  }\n};\n\n\n// ======= QuadTree ========\n\nv.QuadTree.get = function(id) { // make if none\n  var quad = v.QuadTree.all[id],\n      tile = id.split('/');\n  if (! quad) {\n    quad = new v.Quad( L.tile_to_llbounds(tile[0]-0, tile[1]-0, tile[2]-0), tile[0]-0 );\n    v.QuadTree.add( quad );\n  }\n  return quad;\n};\n\nv.QuadTree.add = function(quad) { // don't overwrite\n  var existing = v.QuadTree.all[ quad.key() ];\n  if (! existing) {\n    v.QuadTree.all[ quad.key() ] = quad;\n  }\n};\n\n\n// ======= dotTileQueue : divides main tile rendering up into small chunks =======\n\nv.dotTiles.drawTile = function() { // add to queue\n  v.dotTileQueue.renderQueue.push({\n    canvas: arguments[0], tilePoint: arguments[1], zoom: arguments[2]\n  });\n  //log('drawTile() tile queued: ');// + arguments[1]);\n};\n\nv.dotTileQueue = {\n  lazies: [],\n  cancelRender: function(){\n    //  log('cancelRender() ' + v.lazies.length + ' lazies & ' + v.renderQueue.tasks.length + ' renders');\n    _(v.dotTileQueue.lazies).each(function(lazy) {\n      if (lazy) lazy(); // cancel\n    });\n    v.dotTileQueue.lazies = [];\n    v.dotTileQueue.tasks = [];\n    v.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n  },\n  drawTile: function(args, callback) {\n    var canvas = args.canvas,  tilePoint = args.tilePoint,  zoom = args.zoom,\n        key    = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n        ctx    = canvas.getContext('2d'),\n        quad   = v.QuadTree.get( key ),\n        venues = (v.map.getZoom() < 16) ? quad.venues : quad.getNearbyVenues();\n        \n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    var options = { complete: callback,  partSize: 40,  breathTime: 5 };\n    var lazy = $.lazyEach(venues, function(n, venue){ venue = this; \n      var zoom  = zoomAdjust(),\n          size  = Math.max( 0.5, Math.min(venue.score*zoom*0.5, 20) );\n          pos   = tilePos(venue.location, tilePoint);\n        ctx.prop({ fillStyle: '#000' }).circle( pos.x, pos.y, size ).fill();\n    }, options);\n    \n    v.dotTileQueue.lazies.push( lazy ); // we might have to cancel them shortly\n  }\n};\n\nv.dotTileQueue.throttledRedraw = _.debounce(function(){\n  v.dotTileQueue.cancelRender();\n  v.dotTiles.redraw();\n}, v.redraw_delay);\n\nv.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n\n\n\n// =========== CLUSTER =============\n\nv.clusterTiles.drawTile = function(canvas, tilePoint, zoom) { \n  var key = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n      ctx = canvas.getContext('2d');\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 50, fillStyle: '#fff', strokeStyle: '#333'\n    }).moveTo( center.x, center.y ).fill();\n    \n    // TODO: performance\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue) {\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y ).moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n    \n    _(cluster.venues).each(function(venue) {\n      var pos = tilePos(venue.location, tilePoint);\n      ctx.prop({ fillStyle: venue.color }).circle( pos.x, pos.y, 8 ).fill();\n    });\n  }\n};\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll; }) );\n};\n\nwindow.cluster.center = function() {\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return { lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng) };\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n};\n\nwindow.cluster.getCloseVenues = function(ll) {\n  var zoom = 15, // OPTIMISE\n      tile = L.llz_to_tile( ll.lat, ll.lng, zoom );\n  return v.QuadTree.get( tile.join('/') ).getNearbyVenues();\n};\n\nwindow.cluster.getClosestVenues = function(ll) {\n  return _( cluster.getCloseVenues(ll) ).sortBy(function(venue){\n    return venue.ll.distanceTo( ll );\n  });\n};\n\nwindow.cluster.gather = function (ll) {\n  var localVenues = cluster.getClosestVenues(ll),\n      closest     = localVenues[0];\n\n  if (!closest || ll.distanceTo(closest.ll) > zoomAdjust()*500) { // TODO include zoom level\n    cluster.clear();\n    return;\n  }\n  \n  v.dotTiles.setOpacity( 0.6 );\n  \n//  v.dotTileQueue.cancelRender();\n  cluster.venues = _(localVenues)\n    .chain()\n    .filter(function(venue){ return venue.ll.distanceTo( ll ) < (v.cluster_range); })\n    .slice(0, 12)\n    .sortBy(function(venue) { return -venue.ll.lat; })\n    .value();\n\n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  var bounds   = cluster.bounds(),\n      distance = bounds.getNorthWest().distanceTo( bounds.getSouthEast() );\n\n  var text = //'<p style=\"text-align: center\"><em>' + Math.floor(distance / 90) + ' mins walking</em></p>' +  \n    _.map(cluster.venues, function(venue) {\n      var str = \n      '<b style=\"-webkit-border-radius: 8px; padding: 0 6px;' + \n         'background-color: <%= color %>\">&nbsp;</b> ' +\n        '<a target=\"_new\" href=\"http://foursquare.com/v/<%= id %>\"><%= name %></a>' +\n        ' <em>'+ cat(venue) + '</em><br>';\n    return _.template(str)(venue);\n  }).join(' ');\n\n  popup( \n    new L.LatLng( cluster.venues[0].ll.lat, cluster.venues[0].ll.lng ), \n    text \n  );\n  \n  v.clusterTiles.redraw();\n};\n\n\n//v.dotTileQueue.throttledRedraw();\n\n\n// =========== Quad class =============\n\n\n\nv.Quad.offZero = function(num) { // hack for foursquare API\n  return num === 0 ? '0.00000000001' : num + '';\n};\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    var quad = v.QuadTree.get( that.key() );\n    \n    if (results) { // if called after an actual AJAX request\n      quad.fetched_at = Date.now();\n      quad.venue_count = results.response.venues.length;\n    }\n    \n    //if (results.response.venues.length == 50) // squeeze out some kids\n    var kids = that.divide(); //getChildrenTiles\n    Scan.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    //}\n    \n    if (callback) callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var that = this,\n      directions = [  [-1, -1], [-1, +0], [-1, +1],\n                      [+0, -1], /*[0,0]*/ [+0, +1],\n                      [+1, -1], [+1, +0], [+1, +1]  ];\n  \n  return _.map( directions, function(dir) {\n    return [ that.z,  that.x + dir[0],  that.y + dir[1] ];\n  });\n};\n\nv.Quad.prototype.getNearbyVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles  = this.getNeighbouringTiles(); \n  \n  _.each(tiles, function(t) {\n    var quad = v.QuadTree.get( t.join('/') );\n    _.extend( venues, quad.venues );\n  });\n\n/*  venues = _.filter(venues, function(venue){ \n    var score = v.calcScore( venue );\n    return !venue.hide && (score > highpass);\n  }); */\n  \n  return venues;\n};\n\nv.Quad.prototype.getParentTile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.z - 1);\n};\n\nv.Quad.prototype.worthScanning = function() { \n  var parent  = v.QuadTree.get( this.getParentTile().join('/') ),\n      gparent = v.QuadTree.get( parent.getParentTile().join('/') );\n      \n  var p_n  = parent.venue_count || 50;\n      gp_n = gparent.venue_count || 50;\n\n  return (p_n + gp_n > 95);\n};\n\n\nv.Quad.prototype.getChildrenTiles = function(){\n  var zz = this.z + 1,  x = this.x,  y = this.y;\n      \n  return [\n    [ zz, 2*x, 2*y ],    [ zz, 2*x + 1, 2*y ],\n    [ zz, 2*x, 2*y + 1], [ zz, 2*x + 1, 2*y + 1 ]\n  ];\n};\n\nv.Quad.prototype.tile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.z );\n};\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n};\n\nv.Quad.prototype.done = function() { // FIXME: possible bug here!\n  return (this.z < 19) && (\n    this.fetched_at || _(this.getChildrenTiles()).all( function(tile_arr) {\n      return v.QuadTree.get( tile_arr.join('/') ).done();\n    })\n  );\n};\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter(); },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds( x, ne), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds( s, e ), this.z + 1 )\n  ];\n};\n\n\n\n////////\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: false, offset: new L.Point(0, -24)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n};\n\n","unpause":"\n//Scan.start()\n\n\n","canvas":"  "},"parameters":{"labels":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 10460, -100)","weight":null,"manual":0.49,"id":"labels"},"power":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 0, 1)","weight":null,"manual":0.4,"id":"power"},"highpass":{"initial":0.5,"raw":0.5,"formula":"coax(slider, -1, 40)","weight":null,"manual":0.28,"id":"highpass"}},"iteration":129}