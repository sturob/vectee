{
  "functions": {
    "initial": "_.extend(v, { \n  tileSize: 256,  smallest_search_diagonal: 250,  cluster_range: 250,\n  count: 0,  venues: {},  searches: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ], \n  exclude_categories: a2o([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store', 'Church',\n    'Moving Target', 'Road'\n  ])\n});\n\nv.QuadTree = {\n  all: {},\n  get: function(id){  },\n  add: function(id){  }\n};\n\n\nwindow.cluster = {\n  active: function() { return (cluster.venues.length > 0) },\n  venues: [],\n  contains: function(venue) { return _.contains(cluster.venues, venue) }\n};\n\nv.calcScore = function(venue) {\n  return venue.stats.usersCount/100 * venue.stats.checkinsCount/20;\n};\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n}\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/v.tileSize ) * v.tileSize,\n        y1: Math.floor( bounds.min.y/v.tileSize ) * v.tileSize,\n        x2: Math.ceil( bounds.max.x/v.tileSize ) * v.tileSize,\n        y2: Math.ceil( bounds.max.y/v.tileSize ) * v.tileSize\n      };\n  return locked;\n}\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var cols = Math.ceil((locked.x2 - locked.x1) / v.tileSize),\n      rows = Math.ceil((locked.y2 - locked.y1) / v.tileSize),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (v.tileSize * i), \n          y  = locked.y1 + (v.tileSize * j)\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + v.tileSize, y + v.tileSize) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n}\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/65492/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  $(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n\n  v.map.off('click').on('click', function(e) {\n    cluster.gather(e.latlng);\n  });\n  \n  v.canvasTiles = new L.TileLayer.Canvas();\n  v.canvasTiles.drawTile = function(canvas, tilePoint, zoom) { }\n  v.map.addLayer(v.canvasTiles);\n}\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n",
    "paperjs": "//paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n  var n = 0;\n  _.each(v.scans, function(quad) {\n    \n/*    var poly = L.Polygon([ \n      quad.bounds.getNorthWest(), quad.bounds.getNorthEast(),\n      quad.bounds.getSouthEast(), quad.bounds.getSouthWest()\n    ], {}); */\n    \n    //v.map.addLayer(poly);\n    \n/*    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25); */\n  });\n}\n",
    "instant": "function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\nfunction lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\nfunction tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\nfunction tile2lat(y,z) {\n  var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n  return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n}\n\nwindow.tilesForLocation = function(ll) {\n  var tiles = [];\n  for (var i=1; i<19; i++) {\n    tiles.push([ i, long2tile(ll.lng, i), lat2tile(ll.lat, i) ]);\n  }\n  return tiles;\n}\n\nwindow.zoomAdjust = function() {\n   return Math.pow(2, v.map.getZoom()) / 26214.4\n}\n\nwindow.refetch = function(){\n  window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  window.queue = [];\n  window.startScan( v.map );\n} \n\nwindow.startScan = function(map) {\n  var\tcenter = v.map.getBounds().getCenter();\n  v.scanLevel = v.map.getZoom(); \n \n  v.queue = _( v.map.getVisibleTiles() ).map(function(tile) {\n    return new v.Quad( tile, v.scanLevel );\n  });\n  \n  _( v.queue ).sort(function (a, b) { // sort by closest to the center\n    return a.bounds.getCenter().distanceTo(center) - b.bounds.getCenter().distanceTo(center)\n  });\n\n  nextScan();\n\n  function nextScan() {\n    v.scans = [];\n    v.canvasTiles.redraw();\n\n    if (v.pauseScan) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = v.queue.shift()) {\n      if (v.scanLevel + 1 > up_next.level && up_next.diagonal > v.smallest_search_diagonal) {\n        v.scans[0] = up_next;\n        up_next.scan( nextScan );\n        break;\n      }\n    }\n  }\n};\n\nv.canvasTiles.drawTile = function(canvas, tilePoint, zoom) {\n  function tilePos(ll, tilePoint) {\n    var point = v.map.project( ll );\n    return {  x: point.x - tilePoint.x * v.tileSize,  y: point.y - tilePoint.y * v.tileSize  }\n  }\n\n  var key = zoom + '/' + tilePoint.x + '/' + tilePoint.y;\n\n  var ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.globalAlpha = 1;\n  \n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 50, fillStyle: '#fff', strokeStyle: '#fff'\n    }).moveTo( center.x, center.y ).fill();\n    \n    // TODO: performance\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue) {\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y ).moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n  }\n  ctx.globalAlpha = 1;\n  \n  \n  if (!v.QuadTree.all[key]) return; // kids?\n\n  var i = 0;\n  _(v.QuadTree.all[key].getNearbyVenues()).each(function(venue){\n    var score = v.calcScore( venue ),\n        zoom = zoomAdjust(),\n        size = Math.max( 3,\n          Math.min( Math.pow(score, power) * zoom, 14)\n        );\n        \n    if (! venue.hide && score > highpass) { //var x = 11, y = 30 + 14*i++;\n      var clustered = cluster.active() && cluster.contains( venue ),\n          pos   = tilePos(venue.location, tilePoint),\n          color = clustered ? venue.color : (cluster.active() ? '#555' : '#000');\n\n      ctx.prop({ fillStyle: color }).circle( pos.x, pos.y, clustered ? 8 : size ).fill();\n    }\n  });\n};\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll }) )\n};\n\nwindow.cluster.center = function() {\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return { lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng) }\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n};\n\nwindow.cluster.getCloseVenues = function(ll) {\n  var zoom = 15,\n      x    = long2tile(ll.lng, zoom),\n      y    = lat2tile(ll.lat, zoom),\n      tile = zoom + '/' + x + '/' + y;\n  \n  return v.QuadTree.all[ tile ].getNearbyVenues();\n};\n\nwindow.cluster.getClosestVenues = function(ll) {\n  return _( cluster.getCloseVenues(ll) ).sortBy(function(venue){\n    return venue.ll.distanceTo( ll );\n  });\n}\n\n\nwindow.cluster.gather = function (ll) {\n  var localVenues = cluster.getClosestVenues(ll),\n      closest     = localVenues[0];\n\n  if (ll.distanceTo(closest.ll > 100)) { // TODO include zoom level\n    cluster.venues = [];\n    v.canvasTiles.redraw();\n    return;\n  }\n\n  cluster.venues = _(localVenues).filter(function(venue){\n    return venue.ll.distanceTo( ll ) < v.cluster_range;\n  });\n   \n  // limit to 12 + sort vertically\n  cluster.venues = cluster.venues.slice(0, 12).sort(function (a, b) {\n    return b.ll.lat - a.ll.lat\n  });\n  \n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  \n  var text =  _.map(cluster.venues, function(venue) {\n    var str = \n      '<b style=\"-webkit-border-radius: 8px; padding: 0 6px;' + \n         'background-color: <%= color %>\">&nbsp;</b> ' +\n        '<a target=\"_new\" href=\"http://foursquare.com/v/<%= id %>\"><%= name %></a>' +\n        ' <em>'+ cat(venue) + '</em><br>';\n    return _.template(str)(venue);\n  }).join(' ');\n\n  v.canvasTiles.redraw();\nconsole.log( cluster.bounds() )\n  popup( \n    new L.LatLng( cluster.venues[0].ll.lat, cluster.venues[0].ll.lng ), \n    text \n  );\n}\n\n\nv.canvasTiles.redraw();\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z = v.Quad.offZero,  \n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n            'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n            '&intent=browse' + '&limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n    \n  var got = function (res) { //\n    v.searches[key] = res;\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name in v.exclude_categories) {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    callback && callback(res);\n  };\n  \n  if (v.searches[key]) { // TODO check age\n    // TODO load data. only for trans session caching?\n    got( v.searches[key] );\n  } else {\n    window.currentQuery = $.getJSON(url + url2, got).error(function(res){\n      alert(JSON.parse(res.responseText).meta.errorDetail)\n    });\n  }\n};\n\n\n// Quad class\n\nv.Quad = function(bounds, level) {\n  this.level = level;\n  this.bounds   = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() )\n  this.venues   = {};\n\n  var tile = this.tile();\n  this.x = tile[1];\n  this.y = tile[2];\n  this.z = tile[0];\n\n//this.hit_count      0-50\n//this.ajax_done  boolean\n\n  if (! v.QuadTree.all[ this.key() ]) {\n    v.QuadTree.all[ this.key() ] = this;\n  }\n  return this;\n}\n\nv.Quad.offZero = function(num) { // hack for foursquare API\n  return num === 0 ? '0.00000000001' : num + ''\n}\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var that = this;\n  var directions = [\n    [-1, -1], [-1, +0], [-1, +1],\n    [+0, -1], /*[0,0],*/[+0, +1],\n    [+1, -1], [+1, +0], [+1, +1]\n  ];\n  \n  return _.map( directions, function(dir) {\n    return [ that.z, that.x + dir[0], that.y + dir[1] ].join('/');\n  });\n}\n\nv.Quad.prototype.getNearbyVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles  = this.getNeighbouringTiles();\n  \n  _.each(tiles, function(t) {\n    if (v.QuadTree.all[t]) {\n      _.extend( venues, v.QuadTree.all[t].venues );\n    } \n  });\n\n  venues = _.filter(venues, function(venue){\n    var score = v.calcScore( venue );\n    return !venue.hide && (score > highpass);\n  });\n  \n  return venues;\n}\n\nv.Quad.prototype.getParentTiles = function() {\n  return this.tile(1);\n}\n\nv.Quad.prototype.getChildrenTiles = function(){\n  var zz = this.z + 1,\n      x = this.x, y = this.y;\n      \n  return [\n    [ zz, 2*x, 2*y ],   [ zz, 2*x + 1, 2*y ],\n    [ zz, 2*x, 2*y + 1], [ zz, 2*x + 1, 2*y + 1 ]\n  ];\n}\n\nv.Quad.prototype.tile = function(up) { // up = how many levels to jump up\n  var level = this.level - (up ? up : 0);\n  var lat = this.bounds.getCenter().lat, lng = this.bounds.getCenter().lng;\n\n  return [ level, long2tile(lng, level), lat2tile(lat, level) ];\n}\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n}\n\nv.Quad.prototype.done = function() { // NOT used atm, will be when search can resume\n  if (this.result_count < 50) return true; // got fewer than complete results\n  if (! this.ajax_done || kids.length < 4) return false;\n  \n  if (kids.length == 4) {\n    return kids[0].done() && kids[1].done() && kids[2].done() && kids[3].done();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter() },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( x, ne), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( s, e ), this.level + 1 )\n  ];\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    var venues = results.response.venues;\n    that.ajax_complete = true;\n    that.result_count = venues.length;\n\n    _.each(venues, function(venue){\n      // FIXME dupe hack, fix datamodel please!\n      venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n      venue.color = get_random_color();\n      \n      var tiles = tilesForLocation( venue.location );\n      _.each(tiles, function(tile){\n        var key = tile.join('/'),\n            other_quad = v.QuadTree.all[ tile.join('/') ];\n        if ( other_quad ) {\n          other_quad.venues[ venue.id ] = venue;\n        } else { \n          var x = tile[1],  y = tile[2],  z = tile[0];\n          var new_quad = new v.Quad(\n            new L.LatLngBounds(\n              new L.LatLng( tile2lat(y, z),     tile2long(x, z) ),\n              new L.LatLng( tile2lat(y + 1, z), tile2long(x + 1, z) )\n            ), z);\n          new_quad.venues[ venue.id ] = venue;\n        }\n      })\n    });\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    }\n    callback && callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\n\n\n////////\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: true, offset: new Point(0, -16)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n",
    "unpause": "// save full screen bounds for post-scrolling action later\n//var b = v.map.getBounds();\n//fetchVenues( b.getSouthWest(), b.getNorthEast() );\n\nstartScan(v.map)\n\n\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.49,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.08,
      "id": "highpass"
    }
  },
  "iteration": 74
}