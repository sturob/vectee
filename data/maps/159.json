{"functions":{"initial":"_.extend(v, { \n  tileSize: 256, \n  venues: {},  scans: [],\n  geopos:  [ 51.544303, -0.051344 ]\n});\n\nv.Quad = function(bounds, z) {\n  this.bounds   = bounds;\n  this.venues   = {};\n  this.z        = z;\n  \n  var tile = this.tile();\n  this.x = tile[1];\n  this.y = tile[2];\n//this.barren         boolean\n//this.venues_count   0-50\n//this.fetched_at     Date int\n  return this;\n};\n\nv.QuadTree = {\n  all: {}\n};\n\nv.Venue = function(values) {\n  _.extend( this, values );\n  this.init();\n  return this;\n};\n\nwindow.Scan = {\n  queue: []\n};\n\n\nwindow.cluster = {\n  venues: [],\n  active: function() { return (cluster.venues.length > 0); },\n  contains: function(venue) { return _.contains(cluster.venues, venue); },\n  clear: function(){\n    cluster.venues = [];\n    v.dotTiles.setOpacity( 0.99 );\n    v.clusterTiles.redraw();\n  }\n};\n\n\n// ======== extending Leaflet =========\n\nL.LatLng.prototype.getAllTiles = function() {\n  var ll = this;\n  return _.range(1, 20).map(function(n) {\n    return L.llz_to_tile(ll.lat, ll.lng, n)\n  });\n};\n\nL.llz_to_tile = function( lat, lng, zoom ) {\n  function lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\n  function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\n\n  return [ zoom, long2tile(lng, zoom), lat2tile(lat, zoom) ];\n}\n\nL.tile_to_llbounds = function(zz, xx, yy) {\n  function tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\n  function tile2lat(y,z) {\n    var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n    return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n  }\n  \n  return new L.LatLngBounds(\n    new L.LatLng( tile2lat(yy, zz),   tile2long(xx, zz) ),\n    new L.LatLng( tile2lat(yy+1, zz), tile2long(xx+1, zz) )\n  );\n};\n\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n};\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/v.tileSize ) * v.tileSize,\n        y1: Math.floor( bounds.min.y/v.tileSize ) * v.tileSize,\n        x2: Math.ceil( bounds.max.x/v.tileSize ) * v.tileSize,\n        y2: Math.ceil( bounds.max.y/v.tileSize ) * v.tileSize\n      };\n  return locked;\n};\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var cols = Math.ceil((locked.x2 - locked.x1) / v.tileSize),\n      rows = Math.ceil((locked.y2 - locked.y1) / v.tileSize),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (v.tileSize * i), \n          y  = locked.y1 + (v.tileSize * j),\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + v.tileSize, y + v.tileSize) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n};\n\nv.dataPoint = 'http://localhost:6969/jollywalker/';\n\nwindow.Categories = {};\n\nCategories.fetch = function(callback){\n  $.getJSON(v.dataPoint + 'categories.json', function(res) { \n    window.Categories.tree = res.response.categories;\n    Categories.flat = {};    \n      \n    var loadFlat = function(c, n, root, parent) {\n      c.level  = n++;\n      c.root   = root;\n      c.parent = parent;\n      Categories.flat[c.id] = c;\n      _(c.categories).each(function(sub) { loadFlat(sub, n, root, c); });\n    };\n  \n    _(window.Categories.tree).each(function(c, n){ loadFlat(c, 0, c); });\n    \n    if (callback) callback();\n  });  \n}\n\nCategories.fetch();\n\n\n// =============== studio specific ===============\n\nif (window.Snorkle) { // hacky way to test if in studio\n\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '28px', left: 0, width: '620px', height: '620px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/65711/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = '';//Map data &copy; 2012 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView( new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n\n}\nv.map.boxZoom.disable();\n  \nv.dotTiles = new L.TileLayer.Canvas();\nv.dotTiles.drawTile = function(canvas, tilePoint, zoom) { };\nv.map.addLayer(v.dotTiles);\n\nv.clusterTiles = new L.TileLayer.Canvas();\nv.map.addLayer(v.clusterTiles);\n\nv.layergroup = new L.LayerGroup();\nv.map.addLayer( v.layergroup );\n\nv.map.on('click', function(e) {\n  if (! cluster.active()) {\n    cluster.gather( e.latlng );\n  } else {\n    cluster.clear();\n  }\n});\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n","paperjs":"//paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n  var n = 0;\n  _.each(v.scans, function(quad) {\n     \n/*    var poly = L.Polygon([ \n      quad.bounds.getNorthWest(), quad.bounds.getNorthEast(),\n      quad.bounds.getSouthEast(), quad.bounds.getSouthWest()\n    ], {}); */\n    \n    //v.map.addLayer(poly);\n    /*\n    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25); */\n  });\n};\n\n\n\n\n","instant":"window.zoomAdjust = function() {\n   return Math.pow(2, v.map.getZoom()) / 26214.4;\n};\n\nwindow.clearHighlights = function(){\n  v.layergroup.clearLayers();\n};\n\nwindow.tilePos = function(ll, tilePoint) {\n  var point = v.map.project( ll );\n  return {  x: point.x - tilePoint.x * v.tileSize,  y: point.y - tilePoint.y * v.tileSize  };\n};\n\nwindow.highlightBounds = function(tmpbounds, noclear, options) {\n  var corners = [ tmpbounds.getNorthWest(), tmpbounds.getNorthEast(),\n                  tmpbounds.getSouthEast(), tmpbounds.getSouthWest() ];\n  \n  options = _.defaults(options || {}, { \n    fill: true, color: 'black', stroke: false, fillOpacity: 1\n  });\n\n  var polyline = new L.Polyline( corners,  options );//, opacity: 1\n  if (!noclear) v.layergroup.clearLayers();\n  v.layergroup.addLayer( polyline );\n};\n\n\n// ============== CONFIG ===============\n\n_.extend(v, {\n  no_dots: false,  cluster_range: 250,   redraw_delay:  500,  lowpass: 10\n});\n\n// ===========================\n\nCategories.noShowRoots = _.spawn([\n  \"College & University\", \"Great Outdoors\", \"Professional & Other Places\",\n  \"Travel & Transport\", \"Residence\"\n]); // \"Arts & Entertainment\", \"Food\", \"Nightlife Spot\", \"Shop & Service\"\n\nCategories.noShow = _.spawn([\n    'Bank', 'Government Building', 'Gym'\n]);\n\n// ============================\n\nv.Venue.colors = {\n  white:  one.color('hsva(  0,   0%, 100%, .6)'),\n  red:    one.color('hsva(  0, 100%,  70%, .6)'),\n  yellow: one.color('hsva( 60, 100%, 100%, .6)'),\n  green:  one.color('hsva(120, 100%,  35%, .6)'),\n  blue:   one.color('hsva(240, 100%, 100%, .6)'),\n  trans:  one.color('rgba(255, 255, 255, 0.15)')\n};\n\nv.Venue.categoryColors = {\n  \"Arts & Entertainment\": v.Venue.colors.trans, \n  \"College & University\": v.Venue.colors.trans, \n  \"Food\":                 v.Venue.colors.green, \n  \"Great Outdoors\":       v.Venue.colors.trans, \n  \"Nightlife Spot\":       v.Venue.colors.blue, \n  \"Professional & Other Places\": v.Venue.colors.trans,\n  \"Travel & Transport\":   v.Venue.colors.trans,\n  \"Residence\":            v.Venue.colors.trans,\n  \"Shop & Service\":       v.Venue.colors.red,\n  '':                     v.Venue.colors.trans\n};\n// ============ scanning =============\n\n//Scan.cancel && Scan.cancel();\n\n_.extend(Scan, {\n  savepoint: 'http://localhost:6969/basic/london/',\n  paused:    false,  fake: false,  // dont call foursquare, just viz the scan\n  userless:   true,  // 5000/hour instead of 500, but no user info\n  max_level:    19,  // smallest tile level to scan\n  recurse_n:    10,  // how many levels to recurse when scanning\n  load_crap: false   // load all venues inc. .hide and low scoring\n});\n\nScan.refetch = function(){ \n  //window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  Scan.cancel();\n  Scan.start();\n};\n   \nScan.cancel = function() {\n  console.log('Cancelling');\n  v.layergroup.clearLayers();\n  Scan.queue = [];\n};\n\nScan.save = function(){\n  var save = _( v.venues ).groupBy(function(venue){ return venue.id[2] });\n  \n  save.quads = _.spawn( _( v.QuadTree.all ).keys().filter(function(k){ // scanned keys\n                        return v.QuadTree.get(k).fetched_at;\n                      }),\n                      function() { // what to save\n                        return _.pick( v.QuadTree.get(this), 'fetched_at', 'venue_count' );\n                      });\n  \n  _(save).each(function(to_save, key){\n    console.log( 'saving ' + key );\n    $.post( Scan.savepoint + key + \".json\", JSON.stringify(to_save) );\n  })\n};\n\n\nScan.load = function(){  \n  $.get(Scan.savepoint + \"quads.json\", function(res){\n    var save = JSON.parse(res);\n    \n    if (save) {\n      v.QuadTree.all = {};\n      _.each(save, function(data, key) {\n        var quad = v.QuadTree.get( key );\n        _.extend( quad, data );\n      });\n    }\n    console.log('loaded ' + _(v.QuadTree.all).size() + ' quads');\n  });\n  \n  var allLoaded = _.after(16, function(){\n    reloadVenues();\n    console.log('loaded ' + _(v.venues).size() + ' venues');\n  });\n  \n  _('0123456789abcdef'.split('')).each(function(key){ \n    $.get(Scan.savepoint + key + \".json\", function(res){\n      var _venues = _( JSON.parse(res) );\n      _venues.each(function(venue) {\n        if (! v.venues[ venue.id ]) {\n          new v.Venue( venue );\n        }\n      });\n      allLoaded();\n      console.log('loaded ' + Scan.savepoint + key + '.json');\n    });\n  });\n};\n\n\nScan.start = function() {\n  var\tcenter = v.map.getBounds().getCenter(),\n      initial_level = v.map.getZoom();\n \n  Scan.queue = _( v.map.getVisibleTiles() ).chain().map( function(tile) {\n    var quad = new v.Quad( tile, initial_level ); // hacky\n    return v.QuadTree.get( quad.key() );\n  }).sortBy( function(quad) { // sort by closest to the center\n    return quad.bounds.getCenter().distanceTo( center );\n  }).value();\n\n  nextScan();\n\n  function nextScan() { // called when a scan is complete, inits the next scan\n    v.layergroup.clearLayers();\n    v.dotTileQueue.throttledRedraw();\n    \n    if (Scan.paused) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = Scan.queue.shift()) {\n      if ((up_next.z < (initial_level + Scan.recurse_n)) && // max amount to recurse\n          (up_next.z <= Scan.max_level) &&                  // max level to ever scan\n          true )\n      {\n        highlightBounds( up_next.bounds );\n        up_next.scan( nextScan );\n        break; // leave the while()\n      }\n    }\n  }\n};\n\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z   = v.Quad.offZero,\n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?' + 'v=20120514&' +\n            (Scan.userless ? \n              'client_id=2YR33TS505QZQJNYIXEBOYLELJEPTLNAO4LVBRA3QJS3Z421&' +\n                'client_secret=OIUPQA2AB0OSVZXQDVCXGITU3F3BVP0XFP5QT2ODWZ4WXZQW&' : \n              'oauth_token=ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&') +\n            'intent=browse&' + 'limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n\n  if (Scan.fake) {\n    Scan.queue.push( quad.divide() );\n    _.delay(function(){ if (callback) callback(); }, 20);\n    return;\n  }\n  \n  var real_quad = v.QuadTree.get( key );\n  \n  if (! real_quad.worthScanning()) {\n    real_quad.barren = true;\n    if (callback) callback(); // tail recursion\n  } else if ( real_quad.fetched_at ) {                  // FIX for app\n    //console.warn('already fetched z:' + real_quad.z);\n    if (callback) callback(); // tail recursion\n  } else {\n    var got = function (res) {\n      console.warn(key + ' = ' + res.response.venues.length);\n      _(res.response.venues).each( function(venue){\n        if (!v.venues[ venue.id ]) {\n          new v.Venue( venue );\n        }\n      });\n      if (callback) callback(res); // tail recursion\n    };\n    \n    window.currentQuery = $.get(url + url2, got).error(function(res){\n      var error;\n      try {\n        error = JSON.parse(res.responseText).meta.errorDetail;\n        //alert(error); // if ok\n        console.log(error);\n        window.quota_id = _.delay(Scan.start, 1000 * 60 * 30);\n      } catch(e) {\n        if (e.type == 'unexpected_eos') {\n          console.log('scan bailed. restarting in 15 seconds....');\n          console.log(e);\n          window.delay_id = _.delay(function(){ fetchVenues(quad, callback); }, 15000); // retry\n        }\n      }\n    });\n  }\n};\n\n\n\nwindow.printable = function(){  \n  var zoom = zoomAdjust();\n\n  _(v.venues).each(function(venue){\n    var alt_xy = v.map.project( venue.location ),\n        score  = v.calcScore(),\n        size   = Math.min(score*zoom*0.5, 20),\n        po     = v.map.getPixelBounds();\n    var real_xy = [ alt_xy.x - po.min.x, alt_xy.y - po.min.y ];\n        \n    var c = new Path.Circle( real_xy, size );\n    c.fillColor = '#000';\n  });\n}\n\n//$('img').globalcss('display', 'none')\n/*\nif (0) {\n  printable();\n  paper.view.draw();\n} else {\n  paper.project.layers[0].removeChildren();\n  paper.view.draw();\n}\n*/\n\n//$('#map').css({ opacity: 1 });\n\n\n\n// ==============================\n\n// load venues into Quads\nwindow.reloadVenues = function(){\n  _.each(v.QuadTree.all, function(quad) {\n    quad.venues = {};\n  });\n  _(v.venues).each( function(venue){ venue.insertToQuads() });\n  v.dotTileQueue.throttledRedraw();\n};\n\nv.Venue.saveByScore = function(){\n  for (var i=25; i>=10; i--) {\n    var save = _(v.venues).chain().filter(function(vv){\n                 return vv.displayWorthy() && vv.score > i && (i == 25 || (vv.score < (i + 1)));\n               }).map(function(vv) {\n                 return vv.minimal();\n               }).value();\n    $.post(v.dataPoint + 'london_' + i + '.json', JSON.stringify( save ));\n    console.log('saved venues #' + i);\n  }\n};\n\nv.Venue.loadByScore = function(){\n  for (var i=25; i>=10; i--) {\n    $.getJSON(v.dataPoint + 'london_' + i + '.json', function(res) {\n      var _venues = _( res );\n      _venues.each(function(venue) {\n        if (! v.venues[ venue.id ]) {\n          var venue = new v.Venue( venue );\n          venue.insertToQuads();\n        }\n      });\n      v.dotTileQueue.throttledRedraw();\n    });\n  }\n}\n\nv.Venue.prototype.init = function(){\n  if (v.venues[this.id]) { // safety\n    // this = v.venues[this.id];\n  } else { // add venue if it's new\n    v.venues[this.id] = this;\n  }\n  this.populate();\n}\n\nv.Venue.prototype.populate = function(){\n  this.score = this.calcScore();\n  this.ll    = new L.LatLng( this.location.lat, this.location.lng );\n  this.color = this.calcColor();\n  this.category = {  name: '', id: '' };\n  if (this.categories[0]) {\n    this.category = Categories.flat[ this.categories[0].id ];\n  }\n\n  this.hide = //this.score < highpass ||\n              !this.category.id || \n              this.category.root.name in Categories.noShowRoots ||\n              this.category.name in Categories.noShow;\n};\n \nv.Venue.prototype.insertToQuads = function(){\n  var that = this;\n  if (Scan.load_crap || this.displayWorthy()) {\n    var tiles = that.ll.getAllTiles();\n    _.each(tiles, function(tile){\n      var quad = v.QuadTree.get( tile.join('/') );\n      if (! quad.venues[ that.id ]) {\n        quad.venues[ that.id ] = that;\n      }\n    });\n  }\n};\n\nv.Venue.prototype.minimal = function(){\n  var newVenue = _.pick(this, 'id', 'name', 'stats');\n  if (this.categories[0]) newVenue.categories = [{ id: this.categories[0].id }];\n  newVenue.location = { \n    lat: this.location.lat, lng: this.location.lng, postalCode: this.location.postalCode\n  };\n  return newVenue;\n};\n\nv.Venue.prototype.calcDotSize = function() {\n  var zoom  = zoomAdjust(),\n      size  = 0.8 * Math.max( 0.5, Math.min(this.score * zoom * 0.5, 20) );\n  return size;\n}\n\nv.Venue.prototype.displayWorthy = function(){\n  return (this.score > highpass && !this.hide);\n}\n\nv.Venue.prototype.getColor = function(fullStrength, offset) {\n  var color = this.calcColor();\n  \n  if (fullStrength) {\n    color = color.value(1).alpha(1);\n  } \n\n  var hex = '0123456789abcdef';\n  if (offset) {\n    color = color.value( this.score/15 ).hue( \n      (hex.indexOf(this.id[5]) - hex.indexOf(this.id[4]) ) / 160, true \n    );\n  }\n\n  return color;\n};\n\nv.Venue.prototype.clusterPosition = function(){\n  return _.indexOf(cluster.venues, this);\n};\n\n\n\nv.Venue.prototype.calcColor = function() {\n  if (! this.category) return v.Venue.categoryColors.trans;\n\n  return v.Venue.categoryColors[ this.category.root.name ];\n};\n\nv.Venue.prototype.calcScore = function() {\n  return 11 * Math.pow(this.stats.usersCount/100 * this.stats.checkinsCount/20, 0.12);\n};\n\n\n\n// ======= QuadTree ========\n\nv.QuadTree.get = function(id) { // make if none\n  var quad = v.QuadTree.all[id],\n      tile = id.split('/');\n  if (! quad) {\n    quad = new v.Quad( L.tile_to_llbounds(tile[0]-0, tile[1]-0, tile[2]-0), tile[0]-0 );\n    v.QuadTree.add( quad );\n  }\n  return quad;\n};\n\nv.QuadTree.add = function(quad) { // don't overwrite\n  var existing = v.QuadTree.all[ quad.key() ];\n  if (! existing) {\n    v.QuadTree.all[ quad.key() ] = quad;\n  }\n};\n\nv.QuadTree.level = function(z) {\n  return _.filter(v.QuadTree.all, function(q){ return q.z == z; });\n};\n\n\nv.QuadTree.visualise = function() {\n  clearHighlights();\n  _.each(_.range(15, 20), function(n){\n    _( v.QuadTree.level(n) ).each(function(q){\n      var _venues = _(v.venues);\n      \n      var color = { r:0, g: 0, b:0, white: 0 };\n      var level_adjust = Math.pow( n - 15, 1);\n      \n      _venues.each(function(venue) {\n        color[ venue.calcColor() ] += venue.score;\n      });\n      var white = color.white * level_adjust / 10;\n      if (_venues.size() > 0) {\n        q.highlight({ color: 'rgb(' + int(white + color.r *2* level_adjust) + ',' +\n                                      int(white + color.g *2* level_adjust) + ',' + \n                                      int(white + color.b * level_adjust) + ')' });\n      }\n    });\n  }); \n};\n//v.QuadTree.visualise(); \n\n// ======= dotTileQueue : divides main tile rendering up into small chunks =======\n\nv.dotTiles.drawTile = function() { // add to queue\n  if (! v.no_dots) {\n    v.dotTileQueue.renderQueue.push({\n      canvas: arguments[0], tilePoint: arguments[1], zoom: arguments[2]\n    });\n  }\n  //log('drawTile() tile queued: ');// + arguments[1]);\n};\n\nv.dotTileQueue = {\n  lazies: [],\n  cancelRender: function(){\n//log('cancelRender() ' + v.lazies.length + ' lzs & ' + v.renderQueue.tasks.length + ' rndrs')\n    _(v.dotTileQueue.lazies).each(function(lazy) {\n      if (lazy) lazy(); // cancel\n    });\n    v.dotTileQueue.lazies = [];\n    v.dotTileQueue.tasks  = [];\n    v.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n  },\n  drawTile: function(args, callback) {\n    var canvas = args.canvas,  tilePoint = args.tilePoint,  zoom = args.zoom,\n        key    = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n        ctx    = canvas.getContext('2d'),\n        quad   = v.QuadTree.get( key ),\n        venues = (v.map.getZoom() < 14) ? quad.venues : quad.getNearbyVenues();\n\n    ctx.globalCompositeOperation = \"lighter\";\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    var options = { complete: callback,  partSize: 40,  breathTime: 5 };\n    var lazy = $.lazyEach(venues, function(n, venue){ venue = this; \n      var pos   = tilePos(venue.location, tilePoint);\n        ctx.prop({ fillStyle: venue.getColor().cssa() })\n           .circle( pos.x, pos.y, venue.calcDotSize() ).fill();\n    });\n    \n    v.dotTileQueue.lazies.push( lazy ); // we might have to cancel them shortly\n  }\n};\n\nv.dotTileQueue.throttledRedraw = _.debounce(function(){\n  v.dotTileQueue.cancelRender();\n  v.dotTiles.redraw();\n}, v.redraw_delay);\n\nv.dotTileQueue.renderQueue = async.queue( v.dotTileQueue.drawTile, 1 );\n\n\n\n// =========== CLUSTER =============\n\nv.clusterTiles.drawTile = function(canvas, tilePoint, zoom) { \n  var key = zoom + '/' + tilePoint.x + '/' + tilePoint.y,\n      ctx = canvas.getContext('2d');\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n    \n    // search / 5 minute circles\n    ctx.prop({ strokeStyle: '#ddd', fillStyle: 'rgba(0,0,0,0.3)', lineWidth: 1 })\n         .circle( center.x, center.y, zoomAdjust() *  64 ).fill();\n    \n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 25 * zoomAdjust(), fillStyle: '#fff', \n      strokeStyle: 'rgba(0,0,0,0.5)'\n    }).moveTo( center.x, center.y ).fill();\n    \n    // TODO: performance\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue) {\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y ).moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n    \n    _(cluster.venues).each(function(venue) {\n      var pos   = tilePos(venue.ll, tilePoint),\n          color = venue.getColor(true, true);\n      color = (color.hex() == '#ffffff') ? color.value(0.5) : color;\n      ctx.prop({ fillStyle: color.cssa() })\n         .circle( pos.x, pos.y, zoomAdjust() * 3 ).fill();\n    });\n  }\n};\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll; }) );\n};\n\nwindow.cluster.center = function() {\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return { lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng) };\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n};\n\nwindow.cluster.getCloseVenues = function(ll) {\n  var zoom = 15, // OPTIMISE\n      tile = L.llz_to_tile( ll.lat, ll.lng, zoom );\n  return v.QuadTree.get( tile.join('/') ).getNearbyVenues();\n};\n\nwindow.cluster.getClosestVenues = function(ll) {\n  return _( cluster.getCloseVenues(ll) ).sortBy(function(venue){\n    return venue.ll.distanceTo( ll );\n  });\n};\n\nwindow.cluster.gather = function (ll) {\n  var localVenues = cluster.getClosestVenues(ll);\n  cluster.closest = localVenues[0];\n\n  if (!cluster.closest || ll.distanceTo(cluster.closest.ll) > zoomAdjust()*500) { // TODO include zoom level\n    cluster.clear();\n    return;\n  }\n  \n  v.dotTiles.setOpacity( 0.65 );\n  \n  cluster.venues = _(localVenues).filter(function(venue){\n    return venue.ll.distanceTo( ll ) < v.cluster_range;\n  });\n    \n  var n_within = cluster.venues.length;\n  \n  cluster.venues = _(cluster.venues).chain()\n                      .slice(0, 12)\n                      .sortBy(function(venue) { return -venue.ll.lat; }).value();\n  var others_n = n_within - cluster.venues.length;\n  var postcodes = _(cluster.venues).chain().map(function(venue){ return venue.location.postalCode })\n                    .compact().map(function(pc){ return pc.split(' ')[0].toUpperCase() })\n                    .compact().uniq().value();\n\n  var bounds   = cluster.bounds(),\n      distance = bounds.getNorthWest().distanceTo( bounds.getSouthEast() ),\n      color_count = {};\n\n  var str = '<b style=\"-webkit-border-radius: 8px; padding: 0 6px;' + \n                'background-color: <%= color %>\">&nbsp;</b> ' +\n              '<a target=\"_new\" href=\"http://foursquare.com/v/<%= id %>\"><%= name %></a> ' +\n              '<em><%= category.name %></em><br>';\n\n  var more_str = others_n > 0 ? \n        others_n  + ' more places within ' + v.cluster_range/50 + ' mins -- ' : ''\n  \n  var text = _(cluster.venues).map(function(venue) {\n    var color = venue.getColor(true, true);\n    color = (color.hex() == '#ffffff') ? color.value(0.5) : color;\n      \n    if (color_count[ color.hex() ] >= 0) {\n      color_count[ color.hex() ] += 1;\n    } else {\n      color_count[ color.hex() ] = 0;\n    }\n\n    venue.color = color.alpha(1).cssa(); //.hue((color_count[ color.hex() ] / 30), true)\n    return _.template(str)(venue);\n  }).join(' ') + more_str + postcodes.join(' / ');\n\n  popup( new L.LatLng( cluster.venues[0].ll.lat, cluster.venues[0].ll.lng ), text );\n  \n  v.clusterTiles.redraw();\n};\n\n\n//v.dotTileQueue.throttledRedraw();\n\n\n// =========== Quad class =============\n\n\nv.Quad.offZero = function(num) { // hack for foursquare API\n  return num === 0 ? '0.00000000001' : num + '';\n};\n\nv.Quad.prototype.highlight = function(options) {\n  highlightBounds(this.bounds, true, options);\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    var quad = v.QuadTree.get( that.key() );\n    \n    if (results) { // if called after an actual AJAX request\n      quad.fetched_at = Date.now();\n      quad.venue_count = results.response.venues.length;\n    }\n    if (! quad.barren) {\n      var kids = that.divide(); //getChildrenTiles\n      Scan.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    }\n    if (callback) _.defer( callback, 0 ); // defer to protect the stack\n  };\n  fetchVenues( that, onScanned );\n};\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var that = this,\n      directions = [  [-1, -1], [-1, +0], [-1, +1],\n                      [+0, -1], /*[0,0]*/ [+0, +1],\n                      [+1, -1], [+1, +0], [+1, +1]  ];\n  \n  return _.map( directions, function(dir) {\n    return [ that.z,  that.x + dir[0],  that.y + dir[1] ];\n  });\n};\n\nv.Quad.prototype.getNearbyVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles  = this.getNeighbouringTiles(); \n  \n  _.each(tiles, function(t) {\n    var quad = v.QuadTree.get( t.join('/') );\n    _.extend( venues, quad.venues );\n  });\n  \n  return venues;\n};\n\nv.Quad.prototype.getParentTile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.z - 1);\n};\n\nv.Quad.prototype.getParent = function(){\n  return v.QuadTree.get( this.getParentTile().join('/') );\n}\n\nv.Quad.prototype.worthScanning = function() { \n  var parent  = v.QuadTree.get( this.getParentTile().join('/') ),\n      gparent = v.QuadTree.get( parent.getParentTile().join('/') );\n      \n  var p_n  = (parent.venue_count  == undefined) ? 50 : parent.venue_count;\n      gp_n = (gparent.venue_count == undefined) ? 50 : gparent.venue_count;\n\n  return (p_n + gp_n > 95);\n};\n\n\nv.Quad.prototype.getChildrenTiles = function(){\n  var zz = this.z + 1,  x = this.x,  y = this.y;\n      \n  return [\n    [ zz, 2*x, 2*y ],    [ zz, 2*x + 1, 2*y ],\n    [ zz, 2*x, 2*y + 1], [ zz, 2*x + 1, 2*y + 1 ]\n  ];\n};\n\nv.Quad.prototype.tile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.z );\n};\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n};\n\nv.Quad.prototype.done = function() { // FIXME: possible bug here!\n  return (this.z < 19) && (\n    this.fetched_at || _(this.getChildrenTiles()).all( function(tile_arr) {\n      return v.QuadTree.get( tile_arr.join('/') ).done();\n    })\n  );\n};\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter(); },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds( x, ne), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this.z + 1 ),\n    new v.Quad( new L.LatLngBounds( s, e ), this.z + 1 )\n  ];\n};\n\n\n////////\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: false, offset: new L.Point(0, -12 * zoomAdjust())\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n};","unpause":"\n//Scan.start()\n\n\n","canvas":"  "},"parameters":{"labels":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 10460, -100)","weight":null,"manual":0.49,"id":"labels"},"power":{"initial":0.5,"raw":0.5,"formula":"coax(slider, 0, 1)","weight":null,"manual":0.4,"id":"power"},"highpass":{"initial":0.5,"raw":0.5,"formula":"coax(slider, -1, 40)","weight":null,"manual":0.28,"id":"highpass"}},"iteration":159}