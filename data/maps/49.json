{
  "functions": {
    "initial": "paper.project.layers[0].removeChildren();\n\n_.extend(v, { \n  count: 0,  venues: {},  searches: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ], \n  exclude_categories: a2o([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store', 'Church',\n    'Moving Target'\n  ])\n});\n\nv.QuadTree = {\n  roots: {},\n  all: {}\n};\n\nv.calcScore = function(venue) {\n  return venue.stats.usersCount/100 * venue.stats.checkinsCount/20;\n};\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n}\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var tileSize = 256,\n      bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/tileSize ) * tileSize,\n        y1: Math.floor( bounds.min.y/tileSize ) * tileSize,\n        x2: Math.ceil( bounds.max.x/tileSize ) * tileSize,\n        y2: Math.ceil( bounds.max.y/tileSize ) * tileSize\n      };\n  return locked;\n}\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var tile = 256;\n  var cols = Math.ceil((locked.x2 - locked.x1) / 256),\n      rows = Math.ceil((locked.y2 - locked.y1) / 256),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (tile * i), \n          y  = locked.y1 + (tile * j)\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + tile, y + tile) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n}\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/62930/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  $(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n\n  v.map.off('click').on('click', function(e) {\n    if (e.originalEvent.shiftKey) {\n      fetchVenues(e.latlng);\n    } else {\n      cluster(e.latlng)\n    }\n  });\n}\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n",
    "paperjs": "paper.project.layers[0].removeChildren();\n\nif (v.cluster.length > 0) {\n  var path = new Path();\n  if (v.cluster.length > 2) path.closed = true;\n  path.segments = [];\n  for (var i=0; i < v.cluster.length; i++) {\n    var ll = new L.LatLng(v.cluster[i].ll.lat, v.cluster[i].ll.lng);\n    path.add( v.map.latLngToContainerPoint( ll ) );\n  }\n  path.smooth();\n  _.extend( path, {\n    strokeColor: '#fff', fillColor: '#fff', strokeWidth: 43, strokeCap: 'round'\n  });\n}\n\nvar n = 0;\n_.each(v.scans, function(quad) {\n  var rec = new Path.Rectangle(\n    v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n    v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n  );\n  rec.opacity = 0.2; rec.fillColor = '#000';\n  rec.fillColor.hue = (n++ * 25);\n});\n\n\n_.each(v.venues, function(venue) {\n  var size = v.calcScore(venue);\n  \n  if (size < highpass || venue.hide) return;\n  \n  var pos = v.map.latLngToContainerPoint( new L.LatLng(venue.location.lat, venue.location.lng) );\n  var p = new Point([ pos.x, pos.y ]);\n  var dot = new Path.Circle(p,  Math.min( Math.pow(size, power), 20) );\n  \n  if (v.cluster.length == 1 && (v.cluster[0].id == venue.id)) {\n    dot = new Path.Circle(p, 22);\n    dot.fillColor = '#000';\n  } else if (v.cluster.length > 1) {\n    var in_cluster = _(v.cluster).any(function(item){ \n      return item.id == venue.id\n    });\n    if (in_cluster) {\n      dot = new Path.Circle(p, 10);\n      dot.fillColor = venue.color || '#000';\n    }\n  } else {\n    dot.fillColor = '#000';\n  }\n});\n",
    "instant": "v.smallest_search_diagonal = 350;\nv.cluster_range = 250;\n\nwindow.refetch = function(){\n  window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  window.queue = [];\n  window.startScan( v.map );\n}\n\nwindow.startScan = function(map) {\n  var\tcenter = v.map.getBounds().getCenter();\n\n  v.queue = _( v.map.getVisibleTiles() ).map(function(tile) {\n    return new v.Quad( tile, null, v.map.getZoom() );\n  });\n  \n  _( v.queue ).sort(function (a, b) { // sort by closest to the center\n    //if (Math.floor(a.diagonal) == Math.floor(b.diagonal)) {\n      return a.bounds.getCenter().distanceTo(center) - b.bounds.getCenter().distanceTo(center)\n    //} else {\n      //return Math.floor(b.diagonal) > Math.floor(a.diagonal)\n    //}\n  });\n\n  window.centertile = v.queue[0];\n\n  nextScan();\n\n  function nextScan() {\n    v.scans = [];\n\n    if (v.pauseScan) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = v.queue.shift()) {\n      if (up_next.diagonal > v.smallest_search_diagonal) {\n        v.scans[0] = up_next;\n        up_next.scan( nextScan );\n        break;\n      }\n    }\n  }\n};\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z = v.Quad.offZero,\n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n            'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n            '&intent=browse' + '&limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n    \n  var got = function (res) { //\n    v.searches[key] = res;\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name in v.exclude_categories) {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    callback && callback(res);\n  };\n  \n  if (v.searches[key]) { // TODO check age\n    // TODO load data. only for trans session caching?\n    got( v.searches[key] );\n  } else {\n    window.currentQuery = $.getJSON(url + url2, got);\n  }\n};\n\n\n// Quad class\n\nv.Quad = function(bounds, parent, level) {\n  this.level = level || parent.level + 1;\n  this.bounds   = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() )\n  this.children = [];\n//this.hit_count      0-50\n//this.ajax_done  boolean\n\n  if (parent) {\n    parent.children.push( this );\n    this.parent = parent;\n  }\n  \n  v.QuadTree.all[ this.tile().join('/') ] = this;\n  \n  return this;\n}\n\nv.Quad.offZero = function(num) {\n  return num === 0 ? '0.00000000001' : num + ''\n}\n\nv.Quad.prototype.tile = function() {\n  var lat = this.bounds.getCenter().lat, lng = this.bounds.getCenter().lng;\n  \n  function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\n  function lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\n  \n  return [ this.level, long2tile(lng, this.level), lat2tile(lat, this.level) ];\n}\n\nv.Quad.prototype.key = function() {\n  var b = this.bounds;\n      points = [ b.getNorthEast().lat, b.getNorthEast().lng, \n                 b.getSouthWest().lat, b.getSouthWest().lng ];\n  \n  return _(points).map(v.Quad.offZero).join('_');\n}\n\nv.Quad.prototype.done = function() { // NOT used atm, will be when search can resume\n  var kids = this.children;\n  \n  if (this.result_count < 50) return true; // got fewer than complete results\n  if (! this.ajax_done || kids.length < 4) return false;\n  \n  if (kids.length == 4) {\n    return kids[0].done() && kids[1].done() && kids[2].done() && kids[3].done();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter() },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this ),\n    new v.Quad( new L.LatLngBounds( x, ne), this ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this ),\n    new v.Quad( new L.LatLngBounds( s, e ), this )\n  ];\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    venues = results.response.venues;\n    console.log( that.tile().join('/') +' n=' + venues.length );\n    that.ajax_complete = true;\n    that.result_count = venues.length;\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] )\n      that.children = kids;\n    }\n    callback && callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\n\n\n////////\n\nv.findWithin = function (here, metres) {\n  return _.filter(v.venues, function(venue){\n    var score = v.calcScore( venue );\n    venue.distance = venue.ll.distanceTo( here.ll );\n    return !venue.hide && (score>highpass) && metres > venue.distance;\n  });\n};\n\nwindow.cluster = function (ll) {\n  var closest; // id + distance\n\n  function findClosest(here, all) {\n    var best = null;\n    _.each(all, function(venue) {\n      var score = v.calcScore( venue );\n      if (! best) {\n        best = { id: venue.id, distance: venue.ll.distanceTo( ll ) };\n        return;\n      }\n      if (venue.hide) return;\n      \n      var distance = venue.ll.distanceTo( here );\n      if (distance < best.distance && score > highpass) {\n        best = { id: venue.id, distance: distance };\n      }\n    });\n    return best;\n  }\n  \n  function findCluster(venue, possibles) {\n    v.cluster = v.findWithin(venue, v.cluster_range); // TODO use zoom level\n    return;\n  }\n  \n  closest = findClosest( ll, v.venues ); // find closest venue to tap\n  \n  if (closest.distance > 100) { // TODO include zoom level\n    v.cluster = [];\n    return;\n  }\n\n  v.cluster = [ v.venues[closest.id] ];\n  var venues = _.clone(v.venues);\n\n  findCluster(v.cluster[0], venues);\n  \n  // order by proximity and limit to 12\n  v.cluster = _(v.cluster).sort(function(a, b){ return a.distance > b.distance });\n  v.cluster = v.cluster.slice(0, 12);\n  \n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  \n  var highest = v.cluster[0];\n  _.each(v.cluster, function(venue) {\n    if (venue.ll.lat > highest.ll.lat) highest = venue;\n  });\n  \n  var text =  _.map(v.cluster, function(venue) {\n      return '<b style=\"-webkit-border-radius: 8px; padding: 0 6px; background-color:'\n            + venue.color + '\">&nbsp;</b> '\n            + '<a target=\"_new\" href=\"http://foursquare.com/v/' + venue.id + '\">' \n            + venue.name +  '</a> <em>'+ cat(venue) + '</em><br>'\n    }).join(' ');\n    \n  popup( highest.ll, text );\n}\n\n\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: false, offset: new Point(0, -16)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n",
    "unpause": "// save full screen bounds for post-scrolling action later\n//var b = v.map.getBounds();\n//fetchVenues( b.getSouthWest(), b.getNorthEast() );\n\n\nstartScan(v.map)\n\n// L.Map.prototype.getSharedParentTile = function( block ) {\n//    start at current zoom level\n//    calc tile for x1,y1\n//    if x2,y2 is contained in tile\n//      return tile \n//    else\n//      zoom out and repeat\n// }\n\n\n\n\n\n//var searchStartQuad = v.map.getSharedParentTile( locked );\n\n// order sub searches by proximity + cancel searches of any tile completely offscreen\n\n\n\n\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.42,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.16,
      "id": "highpass"
    }
  },
  "iteration": 49
}