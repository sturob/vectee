{
  "functions": {
    "initial": "paper.project.layers[0].removeChildren();\nv.count = 0;\nv.venues   = {};\nv.searches = {};\nv.scans    = [];\nv.cluster  = [];\n\n\nv.geopos = [ 51.544303, -0.051344 ];\n//geopos = [ 51.538043, -0.061344 ];\n\nv.ll2p = function(lat, lng) {\n  return v.map.layerPointToContainerPoint( v.map.latLngToLayerPoint( new L.LatLng(lat, lng) ) );\n};\n\nv.LL_to_Point = function(ll) {\n  return v.map.layerPointToContainerPoint( v.map.latLngToLayerPoint( ll ) );\n};\n\nv.calcScore = function(venue) {\n  return venue.stats.usersCount/100 * venue.stats.checkinsCount/20;\n};\n\nif (window.Snorkle) {\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/62930/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  \n  $(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n\n  v.map.off('click').on('click', function(e) {\n    if (e.originalEvent.shiftKey) {\n      fetchVenues(e.latlng);\n    } else {\n      cluster(e.latlng)\n    }\n  });\n}\n",
    "paperjs": "// hello!\npaper.project.layers[0].removeChildren();\n\nif (v.cluster.length > 0) {\n  var path = new Path();\n  if (v.cluster.length > 2) path.closed = true;\n  path.segments = [];\n  for (var i=0; i < v.cluster.length; i++) {\n    path.add( v.ll2p( v.cluster[i].ll.lat, v.cluster[i].ll.lng ) );\n  }\n  path.smooth();\n  path.strokeColor = '#fff';\n  path.fillColor   = '#fff';\n  path.strokeWidth = 43;\n  path.strokeCap   = 'round';\n}\n\n/*_.each(v.qdueue, function(quad) {\n  var rec = new Path.Rectangle(\n    v.LL_to_Point( quad.bounds.getNorthWest() ),\n    v.LL_to_Point( quad.bounds.getSouthEast() )\n  );\n  rec.opacity = 0.4; rec.fillColor = '#f00';\n});*/\n\n_.each(v.venues, function(venue) {\n  var size = v.calcScore(venue);\n  \n  if (size < highpass || venue.hide) return;\n  \n  var pos = v.map.layerPointToContainerPoint( \n    v.map.latLngToLayerPoint( new L.LatLng( venue.location.lat, venue.location.lng ) )\n  );\n  var p = new Point([pos.x, pos.y]);\n  var dot = new Path.Circle(p,  Math.min( Math.pow(size, power), 20) );\n  \n  if (v.cluster.length == 1 && (v.cluster[0].id == venue.id)) {\n    dot = new Path.Circle(p, 22);\n    dot.fillColor = '#000';\n  } else if (v.cluster.length > 1) {\n    var in_cluster = _(v.cluster).any(function(item){ \n      return item.id == venue.id\n    });\n    if (in_cluster) {\n      dot = new Path.Circle(p, 4);\n      dot.fillColor = venue.color || '#000';\n    }\n  } else {\n    dot.fillColor = '#000';\n  }\n});\n",
    "instant": "var search_radius = 250; // metres\nvar url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n          'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n          '&intent=browse' + '&limit=50';\n\nfunction get_random_color() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n\nwindow.fetchVenues = function(ll1, ll2, callback) {\n  var key = '' + ll1.lat + ll1.lng,\n      url2 = '';\n\n  if (ll2) {\n    key += ll2.lat + ll2.lng;\n    if (v.scans[key]) return; // stop dupe searches\n    url2 = '&sw=' + ll1.lat +',' + ll1.lng + '&ne=' + ll2.lat +',' + ll2.lng; ;\n  } else {\n    if (v.searches[key]) return; // stop dupe searches\n    url2 = '&radius=' + search_radius + '&ll=' + ll1.lat +',' + ll1.lng;\n  }\n  console.log('searching:' + key);\n  \n  $.getJSON(url + url2, function(res){\n    console.log('found ' + res.response.venues.length);\n    window.results = res; // test\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name == 'Train Station' ||\n            venue.categories[0].name == 'Subway' ||\n            venue.categories[0].name == 'Light Rail' || \n            venue.categories[0].name == 'Highway or Road') {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    delete v.searches[key];\n    delete v.scans[key];\n    console.log('total venues = ' + _( v.venues ).keys().length);\n    \n    callback && callback(res);\n  });\n};\n\n\n\n\nv.Quad = function(bounds, parent){\n  this.bounds = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() )\n  this.children = [];\n  this.parent = parent;\n  // this.hit_count     n 0-50\n  // this.ajax_complete boolean\n  if (parent) parent.children.push( this );\n  return this;\n}\n\nv.Quad.prototype.finished = function() {\n  if (! this.ajax_complete) return false;\n  if (this.result_count < 50) return true;    // got fewer than complete results\n  if (this.children.length < 4) return false; // \n  if (this.children.length == 4) {\n    return this.children[0].finished() && this.children[1].finished() &&\n           this.children[2].finished() && this.children[3].finished();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds;\n  \n  function midLL(ll1, ll2) {\n    return new L.LatLng( (ll1.lat + ll2.lat)/2,  (ll1.lng + ll2.lng)/2 );\n  }\n  \n  var sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n = midLL(nw, ne),      s = midLL(sw, se),\n      w = midLL(nw, sw),      e = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds(w,  n), this ),\n    new v.Quad( new L.LatLngBounds(x, ne), this ),\n    new v.Quad( new L.LatLngBounds(sw, x), this ),\n    new v.Quad( new L.LatLngBounds(s,  e), this )\n  ];\n}\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  console.log('scanning size:' + this.diagonal);\n  \n  var onScanned = function(results) {\n    venues = results.response.venues;\n    console.log('added venues #' + venues.length);\n    \n    that.ajax_complete = true;\n    that.result_count = venues.length;\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] )\n      that.children = kids;\n    }\n    callback && callback();\n  };\n  \n  fetchVenues( that.bounds.getSouthWest(), that.bounds.getNorthEast(), onScanned );\n};\n\nwindow.startScan = function(map) {\n  v.queue = [];\n  var root_bounds = map.getBounds();\n  v.root = new v.Quad( root_bounds ); // currently the initial screen\n  \n  v.root.scan( nextScan );\n\n  function nextScan() {\n    if (v.pauseScan) {\n      setTimeout(nextScan, 10000);\n      return;\n    }\n\n    var up_next = v.queue.shift();\n    \n    if (up_next.diagonal < 350) return; // too close\n    v.scans.push( up_next );\n    up_next.scan( nextScan );\n  }\n}\n\nv.findWithin = function (here, metres) {\n  return _.filter(v.venues, function(venue){\n    var score = v.calcScore( venue );\n\n    return !venue.hide && (score>highpass) && metres > venue.ll.distanceTo( here.ll )\n  });\n};\n\nwindow.cluster = function (ll) {\n  var closest; // id + distance\n\n  function findClosest(here, all) {\n    var best = null;\n    _.each(all, function(venue) {\n      var score = v.calcScore( venue );\n      if (! best) {\n        best = { id: venue.id, distance: venue.ll.distanceTo( ll ) };\n        return;\n      }\n      if (venue.hide) return;\n      \n      var distance = venue.ll.distanceTo( here );\n      if (distance < best.distance && score > highpass) {\n        best = { id: venue.id, distance: distance };\n      }\n    });\n    return best;\n  }\n  \n\n  \n  function findCluster(venue, possibles) {\n    v.cluster = v.findWithin(venue, 250);\n    return;\n    \n    delete possibles[venue.id]; // don't tell me here is nearest to here\n\n    var closest = findClosest( venue.ll, possibles ); // \n    if (closest.distance < 200) {\n      v.cluster.push( v.venues[closest.id] )\n      //console.log( v.venues[closest.id].name );\n      results[closest.id] = v.venues[closest.id];\n      //delete possibles[closest.id];\n      findCluster(v.venues[closest.id], possibles);\n    }\n  }  \n  // find closest venue to tap\n  closest = findClosest( ll, v.venues );\n  \n  if (closest.distance > 100) { // TODO include zoom level\n    v.cluster = [];\n    return;\n  }\n\n  v.cluster = [ v.venues[closest.id] ];\n  var venues = _.clone(v.venues);\n\n  findCluster(v.cluster[0], venues);\n  \n  function cat(v) {\n    if (v.categories.length && v.categories[0]) return v.categories[0];\n  }\n  \n  var highest = v.cluster[0];\n  _.each(v.cluster, function(venue) {\n    if (venue.ll.lat > highest.ll.lat) highest = venue;\n  });\n  \n  var text =  _.map(v.cluster, function(venue) {\n      return '<b style=\"-webkit-border-radius: 8px; padding: 0 6px; background-color:' + venue.color + '\">&nbsp;</b> <a target=\"_new\" href=\"http://foursquare.com/v/' +  venue.id + '\">' + venue.name +  '</a> <em>'+ cat(venue).name + '</em><br>'\n    }).join(' ');\n    \n  popup(\n    highest.ll, text\n  );\n}\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup();\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n",
    "unpause": "\n// save full screen bounds for post-scrolling action later\nvar bounds = v.map.getBounds();\nfetchVenues( bounds.getSouthWest(), bounds.getNorthEast() );\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.42,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.28,
      "id": "highpass"
    }
  },
  "iteration": 31
}