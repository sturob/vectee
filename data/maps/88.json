{
  "functions": {
    "initial": "_.extend(v, { \n  tileSize: 256,  smallest_search_diagonal: 250,  cluster_range: 250,\n  count: 0,  venues: {},  searches: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ], \n  exclude_categories: a2o([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store', 'Church',\n    'Moving Target', 'Road', 'Residential Building (Apartment/Condo)', 'Strip Club'\n  ])\n});\n\nv.QuadTree = {\n  all: {}\n};\n\n\nwindow.cluster = {\n  active: function() { return (cluster.venues.length > 0) },\n  venues: [],\n  contains: function(venue) { return _.contains(cluster.venues, venue) },\n  clear: function(){\n    cluster.venues = [];\n    v.canvasTiles.redraw();\n  }\n}\n\nL.llz_to_tile = function( lat, lng, zoom ) {\n  function lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\n  function long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\n\n  return [ zoom, long2tile(lng, zoom), lat2tile(lat, zoom) ];\n}\n\nL.tile_to_llbounds = function(zz, xx, yy) {\n  function tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\n  function tile2lat(y,z) {\n    var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n    return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n  }\n  \n  return new L.LatLngBounds(\n    new L.LatLng( tile2lat(yy, zz),   tile2long(xx, zz) ),\n    new L.LatLng( tile2lat(yy+1, zz), tile2long(xx+1, zz) )\n  );\n}\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n}\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/v.tileSize ) * v.tileSize,\n        y1: Math.floor( bounds.min.y/v.tileSize ) * v.tileSize,\n        x2: Math.ceil( bounds.max.x/v.tileSize ) * v.tileSize,\n        y2: Math.ceil( bounds.max.y/v.tileSize ) * v.tileSize\n      };\n  return locked;\n}\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var cols = Math.ceil((locked.x2 - locked.x1) / v.tileSize),\n      rows = Math.ceil((locked.y2 - locked.y1) / v.tileSize),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (v.tileSize * i), \n          y  = locked.y1 + (v.tileSize * j)\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + v.tileSize, y + v.tileSize) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n}\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/65711/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  //$(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n  \n  v.canvasTiles = new L.TileLayer.Canvas();\n  v.canvasTiles.drawTile = function(canvas, tilePoint, zoom) { }\n  v.map.addLayer(v.canvasTiles);\n}\n\nv.map.off('click').on('click', function(e) {\n  if (! cluster.active()) {\n    cluster.gather( e.latlng );\n  } else {\n    cluster.clear();\n  }\n});\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n",
    "paperjs": "//paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n  var n = 0;\n  _.each(v.scans, function(quad) {\n    \n/*    var poly = L.Polygon([ \n      quad.bounds.getNorthWest(), quad.bounds.getNorthEast(),\n      quad.bounds.getSouthEast(), quad.bounds.getSouthWest()\n    ], {}); */\n    \n    //v.map.addLayer(poly);\n    /*\n    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25); */\n  });\n}\n",
    "instant": "window.tilesForLocation = function(ll) {\n  var tiles = [];\n  for (var i=1; i<19; i++) {\n    tiles.push( L.llz_to_tile(ll.lat, ll.lng, i) );\n  }\n  return tiles;\n}\n\nwindow.zoomAdjust = function() {\n   return Math.pow(2, v.map.getZoom()) / 26214.4\n}\n\nwindow.refetch = function(){\n  //window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  window.queue = [];\n  window.startScan( v.map );\n} \n\nwindow.startScan = function(map) {\n  var\tcenter = v.map.getBounds().getCenter();\n  v.scanLevel = v.map.getZoom(); \n \n  v.queue = _( v.map.getVisibleTiles() ).chain().map(function(tile) {\n    var quad = new v.Quad( tile, v.scanLevel );\n    v.QuadTree.add( quad );\n    return quad;\n  }).sortBy(function (quad) { // sort by closest to the center\n    return quad.bounds.getCenter().distanceTo( center )\n  }).value();\n\n  nextScan();\n\n  function nextScan() {\n    v.scans = [];\n    v.canvasTiles.redraw();\n\n    if (v.pauseScan) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = v.queue.shift()) {\n      if (v.scanLevel + 1 > up_next.level && up_next.diagonal > v.smallest_search_diagonal) {\n        v.scans[0] = up_next;\n        up_next.scan( nextScan );\n        break;\n      }\n    }\n  }\n};\n\nv.QuadTree.get = function(id) { // make if none\n  var quad = v.QuadTree.all[id],\n      tile = id.split('/');\n  if (! quad) {\n    quad = new v.Quad( L.tile_to_llbounds(tile[0]-0, tile[1]-0, tile[2]-0), tile[0]-0 );\n    v.QuadTree.add( quad );\n  }\n  return quad;\n}\n\nv.QuadTree.add = function(quad) { // don't overwrite\n  var existing = v.QuadTree.all[ quad.key() ];\n  if (! existing) {\n    v.QuadTree.all[ quad.key() ] = quad;\n  }\n}\n\n\nv.calcScore = function(venue) {\n  return 8 * Math.pow(venue.stats.usersCount/100 * venue.stats.checkinsCount/20, 0.15);\n}\n\n\nv.canvasTiles.drawTile = function(canvas, tilePoint, zoom) {\n  function tilePos(ll, tilePoint) {\n    var point = v.map.project( ll );\n    return {  x: point.x - tilePoint.x * v.tileSize,  y: point.y - tilePoint.y * v.tileSize  }\n  }\n\n  var key = zoom + '/' + tilePoint.x + '/' + tilePoint.y;\n\n  var ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.globalAlpha = 1;\n  \n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 50, fillStyle: '#fff', strokeStyle: '#333'\n    }).moveTo( center.x, center.y ).fill();\n    \n    // TODO: performance\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue) {\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y ).moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n  }\n  ctx.globalAlpha = 1;\n  \n  var quad = v.QuadTree.get(key);\n  if (! quad) return; // kids?\n\n  var i = 0;\n  _(quad.getNearbyVenues()).each(function(venue){\n    var score = v.calcScore( venue ),\n        zoom = zoomAdjust(),\n        size = Math.max( 1,\n          Math.min( score * zoom * 0.5, 30)\n        );\n        \n    if (! venue.hide) { // var x = 11, y = 30 + 14*i++;\n      var clustered = cluster.active() && cluster.contains( venue ),\n          pos   = tilePos(venue.location, tilePoint),\n          color = clustered ? venue.color : (cluster.active() ? '#555' : '#000');\n\n      ctx.prop({ fillStyle: color }).circle( pos.x, pos.y, clustered ? 8 : size ).fill();\n    }\n  });\n};\n\n// CLUSTER\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll }) )\n};\n\nwindow.cluster.center = function() {\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return { lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng) }\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n};\n\nwindow.cluster.getCloseVenues = function(ll) {\n  var zoom = 15, // OPTIMISE\n      tile = L.llz_to_tile( ll.lat, ll.lng, zoom );\n  return v.QuadTree.get( tile.join('/') ).getNearbyVenues();\n};\n\nwindow.cluster.getClosestVenues = function(ll) {\n  return _( cluster.getCloseVenues(ll) ).sortBy(function(venue){\n    return venue.ll.distanceTo( ll );\n  });\n};\n\nwindow.cluster.gather = function (ll) {\n  var localVenues = cluster.getClosestVenues(ll),\n      closest     = localVenues[0];\n\n  if (!closest || ll.distanceTo(closest.ll) > zoomAdjust()*500) { // TODO include zoom level\n    cluster.clear();\n    return;\n  }\n\n  cluster.venues = _(localVenues)\n    .chain()\n    .filter(function(venue){ return venue.ll.distanceTo( ll ) < (v.cluster_range) })\n    .slice(0, 12)\n    .sortBy(function(venue) { return -venue.ll.lat })\n    .value();\n\n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  var bounds = cluster.bounds();\n  var distance = bounds.getNorthWest().distanceTo( bounds.getSouthEast() );\n  var text = '<p style=\"text-align: center\"><em>' + Math.floor(distance / 90) + ' mins walking</em></p>' +  \n    _.map(cluster.venues, function(venue) {\n      var str = \n      '<b style=\"-webkit-border-radius: 8px; padding: 0 6px;' + \n         'background-color: <%= color %>\">&nbsp;</b> ' +\n        '<a target=\"_new\" href=\"http://foursquare.com/v/<%= id %>\"><%= name %></a>' +\n        ' <em>'+ cat(venue) + '</em><br>';\n    return _.template(str)(venue);\n  }).join(' ');\n\n  popup( \n    new L.LatLng( cluster.venues[0].ll.lat, cluster.venues[0].ll.lng ), \n    text \n  );\n  \n  v.canvasTiles.redraw();\n}\n\n\n\n\n\n// 5000/hour client_id=CLIENT_ID&client_secret=CLIENT_SECRET\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z = v.Quad.offZero,  \n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n            'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n            '&intent=browse' + '&limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n    \n  var got = function (res) { //\n    v.searches[key] = res;\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name in v.exclude_categories) {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    callback && callback(res);\n  };\n  \n  if (v.searches[key]) { // TODO check age\n    // TODO load data. only for trans session caching?\n    got( v.searches[key] );\n  } else {\n    window.currentQuery = $.getJSON(url + url2, got).error(function(res){\n      alert(JSON.parse(res.responseText).meta.errorDetail)\n    });\n  }\n};\n\n\n// Quad class\n\nv.Quad = function(bounds, level) {\n  this.level = level;\n  this.bounds   = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() );\n  this.venues   = {};\n\n  var tile = this.tile();\n  this.x = tile[1];\n  this.y = tile[2];\n  this.z = tile[0]; \n\n//this.hit_count      0-50\n//this.ajax_done  boolean\n  \n  return this;\n}\n\nv.Quad.offZero = function(num) { // hack for foursquare API\n  return num === 0 ? '0.00000000001' : num + ''\n}\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var that = this,\n      directions = [  [-1, -1], [-1, +0], [-1, +1],\n                      [+0, -1], /*[0,0]*/ [+0, +1],\n                      [+1, -1], [+1, +0], [+1, +1]  ];\n  \n  return _.map( directions, function(dir) {\n    return [ that.z,  that.x + dir[0],  that.y + dir[1] ]\n  });\n}\n\n\nv.Quad.prototype.getNearbyVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles  = this.getNeighbouringTiles();\n  \n  _.each(tiles, function(t) {\n    var quad = v.QuadTree.get( t.join('/') );\n    if (quad) {\n      _.extend( venues, quad.venues );\n    }\n  });\n\n  venues = _.filter(venues, function(venue){ \n    var score = v.calcScore( venue );\n    return !venue.hide && (score > highpass);\n  });\n  \n  return venues;\n}\n\nv.Quad.prototype.getParentTile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, level - 1);\n}\n\nv.Quad.prototype.getChildrenTiles = function(){\n  var zz = this.z + 1,  x = this.x,  y = this.y;\n      \n  return [\n    [ zz, 2*x, 2*y ],    [ zz, 2*x + 1, 2*y ],\n    [ zz, 2*x, 2*y + 1], [ zz, 2*x + 1, 2*y + 1 ]\n  ];\n}\n\nv.Quad.prototype.tile = function() {\n  var center = this.bounds.getCenter();\n  return L.llz_to_tile( center.lat, center.lng, this.level );\n}\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n}\n\nv.Quad.prototype.done = function() { // NOT used atm, will be when search can resume\n  if (this.result_count < 50) return true; // got fewer than complete results\n  if (! this.ajax_done || kids.length < 4) return false;\n  \n  if (kids.length == 4) {\n    return kids[0].done() && kids[1].done() && kids[2].done() && kids[3].done();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter() },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( x, ne), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this.level + 1 ),\n    new v.Quad( new L.LatLngBounds( s, e ), this.level + 1 )\n  ];\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    var venues = results.response.venues;\n    that.ajax_complete = true;\n\n    _.each(venues, function(venue){ // FIXME dupe hack, fix datamodel please!\n      if (! v.venues[ venue.id ] ) {\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n      }\n      \n      var tiles = tilesForLocation( venue.location );\n      _.each(tiles, function(tile){\n        var key = tile.join('/'),\n            other_quad = v.QuadTree.get( tile.join('/') );\n        if (! other_quad.venues[ venue.id ]) {\n          other_quad.venues[ venue.id ] = venue;\n        }\n      })\n    });\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] );\n    }\n    callback && callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\n\n\n////////\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: false, offset: new L.Point(0, -24)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n\n\n\nv.canvasTiles.redraw(); ",
    "unpause": "// save full screen bounds for post-scrolling action later\n//var b = v.map.getBounds();\n//fetchVenues( b.getSouthWest(), b.getNorthEast() );\n\nstartScan( v.map )\n\n\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.4,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.27,
      "id": "highpass"
    }
  },
  "iteration": 88
}