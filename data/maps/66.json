{
  "functions": {
    "initial": "paper.project.layers[0].removeChildren();\n\n_.extend(v, { \n  count: 0,  venues: {},  searches: {},  scans: [],  cluster: [],\n  geopos:  [ 51.544303, -0.051344 ], \n  exclude_categories: a2o([\n    'Neighborhood', 'Bank', 'Government Building', 'Gym', 'College Academic Building',\n    'Office', 'College Residence Hall', 'Bus Station', 'Train Station', 'Bus Line', 'Subway',\n    'Light Rail', 'Train', 'Platform', 'Highway or Road', 'Home (private)', 'Hospital',\n    'Mosque', 'Post Office', 'Building', 'Grocery or Supermarket',\n    'Drugstore or Pharmacy', 'Conference Room', 'Music Store', 'Church',\n    'Moving Target'\n  ])\n});\n\nv.QuadTree = {\n  all: {}\n};\n\n\nwindow.cluster = {\n  active: function() { return (cluster.venues.length > 0) },\n  venues: [],\n  contains: function(venue) { return _.contains(cluster.venues, venue) }\n}\n\n\nv.calcScore = function(venue) {\n  return venue.stats.usersCount/100 * venue.stats.checkinsCount/20;\n};\n\nL.Map.prototype.latLngToContainerPoint = function( ll ) {\n  return this.layerPointToContainerPoint( this.latLngToLayerPoint( ll ) );\n}\n\nL.Map.prototype.getOSMLockedBounds = function() { // square ATM but should be quadrangle\n  var tileSize = 256,\n      bounds   = this.getPixelBounds(),\n      size = Math.max( bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y );\n      locked = {\n        x1: Math.floor( bounds.min.x/tileSize ) * tileSize,\n        y1: Math.floor( bounds.min.y/tileSize ) * tileSize,\n        x2: Math.ceil( bounds.max.x/tileSize ) * tileSize,\n        y2: Math.ceil( bounds.max.y/tileSize ) * tileSize\n      };\n  return locked;\n}\n\nL.Map.prototype.getVisibleTiles = function () {\n  var locked = this.getOSMLockedBounds();\n  var tile = 256;\n  var cols = Math.ceil((locked.x2 - locked.x1) / 256),\n      rows = Math.ceil((locked.y2 - locked.y1) / 256),\n      tiles = [];\n\n  for (i=0; i<cols; i++) {\n    for (j=0; j<rows; j++) {\n      var x  = locked.x1 + (tile * i), \n          y  = locked.y1 + (tile * j)\n          nw = this.unproject( new L.Point(x, y) ),\n          se = this.unproject( new L.Point(x + tile, y + tile) );\n      tiles.push( new L.LatLngBounds(nw, se) );\n    }\n  }\n  return tiles;\n}\n\nif (window.Snorkle) { // hacky way to test if in studio\n  $('<div id=\"map\">').insertAfter('#meh').css({\n    margin: '8px', overflow: 'hidden', position: 'absolute',\n    opacity: 1, zIndex: '100', top: '24px', left: 0, width: '620px', height: '870px'\n  });\n\n  v.map = new L.Map('map');\n\n  var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/62930/256/{z}/{x}/{y}.png',\n\t\t  cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',\n\t\t  cloudmade = new L.TileLayer(cloudmadeUrl, {minZoom: 10, maxZoom: 19, attribution: cloudmadeAttribution});\n\n  v.map.setView(new L.LatLng(v.geopos[0], v.geopos[1]), 15).addLayer(cloudmade);\n  v.map.boxZoom.disable();\n\n  $(canvas.el).css({ background: 'rgba(0,0,0,0.2)' })\n\n  v.map.off('click').on('click', function(e) {\n    if (e.originalEvent.shiftKey) {\n      fetchVenues(e.latlng);\n    } else {\n      cluster.gather(e.latlng);\n    }\n  });\n  \n  v.canvasTiles = new L.TileLayer.Canvas();\n  v.canvasTiles.drawTile = function(canvas, tilePoint, zoom) { }\n  v.map.addLayer(v.canvasTiles);\n}\n\nwindow.get_random_color = function() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n}\n",
    "paperjs": "paper.project.layers[0].removeChildren();\n\nif (v.scans.length > 0) {\n\n  var n = 0;\n  _.each(v.scans, function(quad) {\n    var rec = new Path.Rectangle(\n      v.map.latLngToContainerPoint( quad.bounds.getNorthWest() ),\n      v.map.latLngToContainerPoint( quad.bounds.getSouthEast() )\n    );\n    rec.opacity = 0.2; rec.fillColor = '#000';\n    rec.fillColor.hue = (n++ * 25);\n  });\n}\n\nreturn;\n\nif (v.cluster.length > 0) {\n  var path = new Path();\n  if (v.cluster.length > 2) path.closed = true;\n  path.segments = [];\n  for (var i=0; i < v.cluster.length; i++) {\n    var ll = new L.LatLng(v.cluster[i].ll.lat, v.cluster[i].ll.lng);\n    path.add( v.map.latLngToContainerPoint( ll ) );\n  }\n  path.smooth();\n  _.extend( path, {\n    strokeColor: '#fff', fillColor: '#fff', strokeWidth: 43, strokeCap: 'round'\n  });\n}\n\n\n\n\n_.each(v.venues, function(venue) {\n  var size = v.calcScore(venue);\n  \n  if (size < highpass || venue.hide) return;\n  \n  var pos = v.map.latLngToContainerPoint( new L.LatLng(venue.location.lat, venue.location.lng) );\n  var p = new Point([ pos.x, pos.y ]);\n  var dot = new Path.Circle(p,  Math.min( Math.pow(size, power), 20) );\n  \n  if (v.cluster.length == 1 && (v.cluster[0].id == venue.id)) {\n    dot = new Path.Circle(p, 22);\n    dot.fillColor = '#000';\n  } else if (v.cluster.length > 1) {\n    var in_cluster = _(v.cluster).any(function(item){ \n      return item.id == venue.id\n    });\n    if (in_cluster) {\n      dot = new Path.Circle(p, 10);\n      dot.fillColor = venue.color || '#000';\n    }\n  } else {\n    dot.fillColor = '#000';\n  }\n});\n",
    "instant": "v.smallest_search_diagonal = 250;\nv.cluster_range = 350; \n\nwindow.refetch = function(){\n  window.currentQuery && window.currentQuery.abort && window.currentQuery.abort();\n  window.queue = [];\n  window.startScan( v.map );\n} \n\nwindow.startScan = function(map) {\n  var\tcenter = v.map.getBounds().getCenter();\n  v.scanLevel = v.map.getZoom(); \n \n  v.queue = _( v.map.getVisibleTiles() ).map(function(tile) {\n    return new v.Quad( tile, null, v.scanLevel );\n  });\n  \n  _( v.queue ).sort(function (a, b) { // sort by closest to the center\n    //if (Math.floor(a.diagonal) == Math.floor(b.diagonal)) {\n      return a.bounds.getCenter().distanceTo(center) - b.bounds.getCenter().distanceTo(center)\n    //} else {\n      //return Math.floor(b.diagonal) > Math.floor(a.diagonal)\n    //}\n  });\n\n  nextScan();\n\n  function nextScan() {\n    v.scans = [];\n    v.canvasTiles.redraw();\n\n    if (v.pauseScan) { setTimeout(nextScan, 10000); return; }\n    \n    var up_next;\n    while (up_next = v.queue.shift()) {\n      if (v.scanLevel + 1 > up_next.level && up_next.diagonal > v.smallest_search_diagonal) {\n        v.scans[0] = up_next;\n        up_next.scan( nextScan );\n        break;\n      }\n    }\n  }\n}; \n\nv.canvasTiles.drawTile = function(canvas, tilePoint, zoom) {\n  \n  function tilePos(ll, tilePoint) {\n    var point = v.map.project( ll );\n    return {  x: point.x - tilePoint.x * 256,  y: point.y - tilePoint.y * 256  }\n  }\n  var ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.globalAlpha = .8;\n  \n  if (cluster.active()) {\n    var center = tilePos( cluster.center(), tilePoint );\n\n    ctx.beginPath().prop({\n      lineCap: 'round', lineWidth: 50, fillStyle: '#fff', strokeStyle: '#fff'\n    });\n\n    ctx.moveTo( center.x, center.y ).fill();\n    \n    // TODO:\n    // var tileBounds = new LngLatBounds();\n    // if (tileBounds.intersects( v.cluster.bounds )) {\n    // if (v.cluster.length > 2) path.closed = true;\n\n    var n = 0;\n    _(cluster.venues).each(function(venue){\n      var pre = cluster.venues[n-1] || _(cluster.venues).last(),\n          pre_xy = tilePos(pre.ll, tilePoint),\n          xy     = tilePos(venue.ll, tilePoint);\n      ctx.lineTo( xy.x, xy.y );\n      ctx.moveTo( center.x, center.y ).fill();\n      n++;\n    });\n    ctx.stroke().closePath();\n  }\n  ctx.globalAlpha = 0.8;\n  \n  var text = zoom + '/' + tilePoint.x + '/' + tilePoint.y;\n  \n  if (!v.QuadTree.all[text]) return; // kids?\n\n  var i = 0;\n  _(v.QuadTree.all[text].getLooseVenues()).each(function(venue){\n    var score = v.calcScore( venue ),\n        zoom = v.map.getZoom() / 16,\n        size = Math.min( Math.pow(score, power), 20) * zoom;\n        \n    if (! venue.hide && score > highpass) { //var x = 11, y = 30 + 14*i++;\n      var clustered = cluster.active() && cluster.contains( venue ),\n          pos   = tilePos(venue.location, tilePoint),\n          color = clustered ? venue.color : '#000';\n\n      ctx.prop({ fillStyle: color })\n         .circle( pos.x, pos.y, clustered ? 8 : size ).fill();\n    }\n  });\n};\n\n\nwindow.cluster.bounds = function() { \n  return new L.LatLngBounds( _.map(cluster.venues, function(venue) { return venue.ll }) )\n};\n\nwindow.cluster.center = function(){\n  var count = cluster.venues.length;\n  var total = _(cluster.venues).reduce(function(tally, venue) {\n    if (tally) {\n      return {\n        lat: (tally.lat + venue.ll.lat),  lng: (tally.lng + venue.ll.lng)\n      }\n    } else {\n      return venue.ll;\n    }\n  }, null);\n  \n  return new L.LatLng( total.lat/count, total.lng/count );\n  //_each(cluster.venues, function() \n};\n\nwindow.cluster.gather = function (ll) {\n  var closest; // id + distance\n\n  function findClosest(here, all) {\n    var best = null;\n    _.each(all, function(venue) {\n      var score = v.calcScore( venue );\n      if (! best) {\n        best = { id: venue.id, distance: venue.ll.distanceTo( ll ) };\n        return;\n      }\n      if (venue.hide) return;\n      \n      var distance = venue.ll.distanceTo( here );\n      if (distance < best.distance && score > highpass) {\n        best = { id: venue.id, distance: distance };\n      }\n    });\n    return best;\n  }\n  \n  v.findWithin = function (here, metres) {\n    return _.filter(v.venues, function(venue){\n      var score = v.calcScore( venue );\n      venue.distance = venue.ll.distanceTo( here.ll );\n      return !venue.hide && (score>highpass) && metres > venue.distance;\n    });\n  };\n  \n  function findCluster(venue, possibles) {\n    cluster.venues = v.findWithin(venue, v.cluster_range); // TODO use zoom level\n    return;\n  }\n  \n  closest = findClosest( ll, v.venues ); // find closest venue to tap\n  \n  if (closest.distance > 100) { // TODO include zoom level\n    cluster.venues = [];\n    v.canvasTiles.redraw();\n    return;\n  }\n\n  cluster.venues = [ v.venues[closest.id] ];\n  var venues = _.clone(v.venues);\n\n  findCluster(cluster.venues[0], venues);\n   \n  // order by proximity and limit to 12\n  _(cluster.venues).sort(function(a, b){ return a.distance - b.distance });\n  cluster.venues = cluster.venues.slice(0, 12);\n  \n  function cat(venue) {\n    if (venue.categories.length && venue.categories[0] && venue.categories[0].name) {\n      return venue.categories[0].name;\n    }\n  }\n  \n  \n  var text =  _.map(cluster.venues, function(venue) {\n      return '<b style=\"-webkit-border-radius: 8px; padding: 0 6px; background-color:'\n            + venue.color + '\">&nbsp;</b> '\n            + '<a target=\"_new\" href=\"http://foursquare.com/v/' + venue.id + '\">' \n            + venue.name +  '</a> <em>'+ cat(venue) + '</em><br>'\n    }).join(' ');\n\n  v.canvasTiles.redraw();\n\n  popup( \n    new L.LatLng( cluster.bounds().getNorthWest().lat, cluster.bounds().getCenter().lng ), \n    text \n  );\n}\n\n\n\n\nv.canvasTiles.redraw();\n\nwindow.fetchVenues = function(quad, callback) {\n  var ll1 = quad.bounds.getSouthWest(), ll2 = quad.bounds.getNorthEast(),\n      z = v.Quad.offZero,\n      key = quad.key(),\n      url = 'https://api.foursquare.com/v2/venues/search?oauth_token=' + \n            'ZUX1IEBBXVCDZ305PSTJULXRG3PFIK4W2LN2W01BRI4WI2BR&v=20120514'+\n            '&intent=browse' + '&limit=50';\n      url2 = '&sw=' + z(ll1.lat) +',' + z(ll1.lng) + '&ne=' + z(ll2.lat) +',' + z(ll2.lng);\n    \n  var got = function (res) { //\n    v.searches[key] = res;\n    _(res.response.venues).each(function(venue){\n      if (venue.categories.length) {\n        if (venue.categories[0].name in v.exclude_categories) {\n          venue.hide = true;\n        }\n      }\n      if (! v.venues[venue.id]) { // dont reinsert venue\n        venue.ll = new L.LatLng( venue.location.lat, venue.location.lng );\n        venue.color = get_random_color();\n        v.venues[venue.id] = venue;\n      }\n    });\n    \n    callback && callback(res);\n  };\n  \n  if (v.searches[key]) { // TODO check age\n    // TODO load data. only for trans session caching?\n    got( v.searches[key] );\n  } else {\n    window.currentQuery = $.getJSON(url + url2, got).error(function(res){\n      alert(JSON.parse(res.responseText).meta.errorDetail)\n    });\n  }\n};\n\n\n// Quad class\n\nv.Quad = function(bounds, parent, level) {\n  this.level = level || parent.level + 1;\n  this.bounds   = bounds;\n  this.diagonal = bounds.getNorthWest().distanceTo( bounds.getSouthEast() )\n  this.children = [];\n  this.venues = {};\n  this.mapUrl = 'http://c.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/62930/256/' + this.key() + '.png';\n//this.hit_count      0-50\n//this.ajax_done  boolean\n\n  if (parent) {\n    parent.children.push( this );\n    this.parent = parent;\n  }\n  \n  v.QuadTree.all[ this.key() ] = this;\n  \n  return this;\n}\n\nv.Quad.offZero = function(num) {\n  return num === 0 ? '0.00000000001' : num + ''\n}\n\n\nv.Quad.prototype.getNeighbouringTiles = function () {\n  var directions = [\n    [-1, -1], [-1, +0], [-1, +1],\n    [+0, -1], /*[0,0],*/[+0, +1],\n    [+1, -1], [+1, +0], [+1, +1]\n  ];\n  var tile = this.tile();\n\n  var neighbours = [];\n  \n  _.each( directions, function(dir) {\n    neighbours.push( [ tile[0], tile[1]+dir[0], tile[2]+dir[1] ].join('/') );\n  });\n  \n  return neighbours;\n}\n\nv.Quad.prototype.getLooseVenues = function() { \n  var venues = _.clone(this.venues),\n      tiles = this.getNeighbouringTiles();\n  \n  _.each(tiles, function(t) {\n    if (v.QuadTree.all[t]) {\n      _.extend( venues, v.QuadTree.all[t].venues );\n    }\n  });\n  \n  return venues;\n  // include neighbours - so cross tiles works \n}\n\n\nv.Quad.prototype.calcParent = function() {\n  return this.tile(1);\n}\n\nfunction long2tile(lon,zoom) { return Math.floor((lon+180)/360*Math.pow(2,zoom)); }\nfunction lat2tile(lat,zoom)  { return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)); }\nfunction tile2long(x,z) { return (x/Math.pow(2,z)*360-180); }\nfunction tile2lat(y,z) {\n  var n=Math.PI-2*Math.PI*y/Math.pow(2,z);\n  return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));\n}\n\n\nwindow.tilesForLocation = function(ll) {\n  var tiles = [];\n  for (var i=1; i<19; i++) {\n    tiles.push([ i, long2tile(ll.lng, i), lat2tile(ll.lat, i) ]);\n  }\n  return tiles;\n}\n\n\nv.Quad.prototype.tile = function(up) { // up = how many levels to jump up\n  var level = this.level - (up ? up : 0);\n  var lat = this.bounds.getCenter().lat, lng = this.bounds.getCenter().lng;\n    \n  return [ level, long2tile(lng, level), lat2tile(lat, level) ];\n}\n\nv.Quad.prototype.key = function() {\n  return this.tile().join('/');\n}\n\nv.Quad.prototype.done = function() { // NOT used atm, will be when search can resume\n  var kids = this.children;\n  \n  if (this.result_count < 50) return true; // got fewer than complete results\n  if (! this.ajax_done || kids.length < 4) return false;\n  \n  if (kids.length == 4) {\n    return kids[0].done() && kids[1].done() && kids[2].done() && kids[3].done();\n  }\n}\n\nv.Quad.prototype.divide = function() {\n  var bounds = this.bounds,\n      midLL = function(a, b) { return (new L.LatLngBounds(a, b)).getCenter() },  \n      sw = bounds.getSouthWest(), nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(), ne = bounds.getNorthEast(),\n      n  = midLL(nw, ne),         s  = midLL(sw, se),\n      w  = midLL(nw, sw),         e  = midLL(ne, se),    x = midLL(n,  s);\n  \n  return [ // sw, ne\n    new v.Quad( new L.LatLngBounds( w, n ), this ),\n    new v.Quad( new L.LatLngBounds( x, ne), this ),\n    new v.Quad( new L.LatLngBounds(sw, x ), this ),\n    new v.Quad( new L.LatLngBounds( s, e ), this )\n  ];\n};\n\n\nv.Quad.prototype.scan = function(callback) {\n  var that = this;\n  var onScanned = function(results) {\n    venues = results.response.venues;\n    //console.log( that.key() +' n=' + venues.length );\n    that.ajax_complete = true;\n    that.result_count = venues.length;\n\n    _.each(venues, function(venue){\n      var tiles = tilesForLocation(venue.location);\n      _.each(tiles, function(tile){\n        var key = tile.join('/'),\n            other_quad = v.QuadTree.all[ tile.join('/') ];\n        if ( other_quad ) {\n          other_quad.venues[ venue.id ] = venue;\n        } else { \n          var x = tile[1],  y = tile[2],  z = tile[0];\n          var new_quad = new v.Quad(\n            new L.LatLngBounds(\n              new L.LatLng( tile2lat(y, z),     tile2long(x, z) ),\n              new L.LatLng( tile2lat(y + 1, z), tile2long(x + 1, z) )\n            ), null, z);\n          new_quad.venues[ venue.id ] = venue;\n        }\n      })\n      \n    });\n    \n    //that.venues = venues;\n    \n    if (venues.length == 50) { // squeeze out some kids\n      var kids = that.divide();\n      v.queue.push( kids[0], kids[1], kids[2], kids[3] )\n      that.children = kids;\n    }\n    callback && callback();\n  };\n  fetchVenues( that, onScanned );\n};\n\n\n\n////////\n\n\n\nwindow.popup = function(latlng, content){\n  var popup = new L.Popup({ \n    closeButton: false, autoPan: true, offset: new Point(0, -16)\n  });\n  popup.setLatLng( latlng );\n  popup.setContent( content );\n  v.map.openPopup( popup );\n}\n",
    "unpause": "// save full screen bounds for post-scrolling action later\n//var b = v.map.getBounds();\n//fetchVenues( b.getSouthWest(), b.getNorthEast() );\n\nstartScan(v.map)\n\n\n",
    "canvas": "  "
  },
  "parameters": {
    "labels": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 10460, -100)",
      "weight": null,
      "manual": 0.49,
      "id": "labels"
    },
    "power": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, 0, 1)",
      "weight": null,
      "manual": 0.35000000000000003,
      "id": "power"
    },
    "highpass": {
      "initial": 0.5,
      "raw": 0.5,
      "formula": "coax(slider, -1, 40)",
      "weight": null,
      "manual": 0.19,
      "id": "highpass"
    }
  },
  "iteration": 66
}